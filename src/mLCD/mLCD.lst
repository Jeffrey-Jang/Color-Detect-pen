CCS PCH C Compiler, Version 4.130, 3850               14-12-15 20:18

               Filename: D:\PIC\LCD\mLCD\mLCD.lst

               ROM used: 8698 bytes (27%)
                         Largest free fragment is 23558
               RAM used: 102 (7%) at main() level
                         206 (13%) worst case
               Stack:    11 worst case (6 in main + 5 for interrupts)

*
0200:  GOTO   222C
*
0208:  MOVWF  04
020A:  MOVFF  FD8,05
020E:  MOVFF  FE0,06
0212:  MOVLB  0
0214:  MOVFF  FE9,0C
0218:  MOVFF  FEA,07
021C:  MOVFF  FE1,08
0220:  MOVFF  FE2,09
0224:  MOVFF  FD9,0A
0228:  MOVFF  FDA,0B
022C:  MOVFF  FF3,12
0230:  MOVFF  FF4,13
0234:  MOVFF  FFA,14
0238:  MOVFF  FF5,15
023C:  MOVFF  FF6,16
0240:  MOVFF  FF7,17
0244:  MOVFF  00,0E
0248:  MOVFF  01,0F
024C:  MOVFF  02,10
0250:  MOVFF  03,11
0254:  BTFSS  FF2.4
0256:  GOTO   0260
025A:  BTFSC  FF2.1
025C:  GOTO   03F4
0260:  BTFSS  F9D.5
0262:  GOTO   026C
0266:  BTFSC  F9E.5
0268:  GOTO   041E
026C:  MOVFF  0E,00
0270:  MOVFF  0F,01
0274:  MOVFF  10,02
0278:  MOVFF  11,03
027C:  MOVFF  0C,FE9
0280:  MOVFF  07,FEA
0284:  BSF    07.7
0286:  MOVFF  08,FE1
028A:  MOVFF  09,FE2
028E:  MOVFF  0A,FD9
0292:  MOVFF  0B,FDA
0296:  MOVFF  12,FF3
029A:  MOVFF  13,FF4
029E:  MOVFF  14,FFA
02A2:  MOVFF  15,FF5
02A6:  MOVFF  16,FF6
02AA:  MOVFF  17,FF7
02AE:  MOVF   04,W
02B0:  MOVFF  06,FE0
02B4:  MOVFF  05,FD8
02B8:  RETFIE 0
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
.................... #fuses NOWDT, HS, NOLVP 
.................... #device *=16 adc=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "user_bootloader.h" 
.................... //Reset Vector Address 
.................... #build(reset=0x200) 
.................... //Intterupts Vector Address 
.................... #build(interrupt=0x208) 
....................  
.................... //Bootloader Area 
.................... #org 0x0000,0x01ff 
.................... void bootloader()  
.................... { 
.................... #asm 
....................   nop //No Operation 
*
0000:  NOP   
.................... #endasm 
.................... }  
0002:  RETURN 0
....................  
....................  
.................... #include "mTFT.h" 
.................... #ifndef __ILI9341_H 
.................... #define __ILI9341_H 
....................  
.................... //============================================================================== 
.................... //============================================================================== 
.................... //============================================================================== 
....................  
.................... #byte TRISC = 0xF94 
.................... #byte TRISD = 0xF95 
....................  
.................... #byte PORTC = 0xF82 
.................... #byte PORTD = 0xF83 
....................  
.................... #bit  SDO=PORTC.5 
.................... #bit  SDI=PORTC.4 
.................... #bit  SCK=PORTC.3 
....................  
.................... #bit  TRIS_SDO=TRISC.5 
.................... #bit  TRIS_SDI=TRISC.4 
.................... #bit  TRIS_SCK=TRISC.3 
....................  
....................  
.................... #define pl() printf("LINE=%d\n",__LINE__); 
.................... //============================================================================== 
.................... // Connection of module TFT. 
.................... // 
.................... // VCC      <<<>>> 5 V. 
.................... // GND      <<<>>> GND. 
.................... // TFT_CS   <<<>>> PORTD.0 You can change this pin. 
.................... // TFT_REST <<<>>> PORTD.1 You can change this pin. 
.................... // TFT_D/C  <<<>>> PORTD.2 You can change this pin. 
.................... // TFT_SDI  <<<>>> Connect to SDO MCU. 
.................... // TFT_SCK  <<<>>> Connect to SCK MCU. 
.................... // TFT_SDO  <<<>>> Connect to SDI MCU. 
.................... // 
.................... //============================================================================== 
.................... #byte TRISD = 0xF95 
.................... #byte PORTD = 0xF83 
....................  
.................... #bit  TFT_CS=PORTD.0 
.................... #bit  TRIS_CS=TRISD.0 
....................  
.................... #bit  TFT_RES=PORTD.1 
.................... #bit  TRIS_RES=TRISD.1 
....................  
.................... #bit  TFT_DC=PORTD.2 
.................... #bit  TRIS_DC=TRISD.2 
....................  
.................... //============================================================================== 
.................... // Connection of MCP3202. 
.................... // 
.................... // VCC      <<<>>> 5 V. 
.................... // GND      <<<>>> GND. 
.................... // MCP_CS   <<<>>> PORTD.3 You can change this pin. 
.................... // CH0      <<<>>> Y+ 
.................... // CH1      <<<>>> X+ 
.................... // MCP_SDI  <<<>>> Connect to SDO MCU. 
.................... // MCP_SCK  <<<>>> Connect to SCK MCU. 
.................... // MCP_SDO  <<<>>> Connect to SDI MCU. 
.................... //  
.................... //============================================================================== 
....................  
.................... #bit TRIS_Yp = TRISD.7 
.................... #bit TRIS_Xp = TRISD.6 
.................... #bit TRIS_Ym = TRISD.5 
.................... #bit TRIS_Xm = TRISD.4 
....................  
.................... #bit TRIS_TS_CS = TRISD.3 
.................... #bit TS_CS = PORTD.3 
....................  
.................... #bit Yp = PORTD.7 
.................... #bit Xp = PORTD.6 
.................... #bit Ym = PORTD.5 
.................... #bit Xm = PORTD.4 
....................  
.................... //============================================================================== 
.................... //============================================================================== 
.................... #byte INTCON=0xFF2 
.................... #byte PIE1=0xF9D 
.................... #byte PIR1 = 0xf9e 
....................  
.................... #byte SSPBRG= 0xfaf 
.................... #byte SSPBUF= 0xfc9 
.................... #byte SSPADD= 0xfc8 
.................... #byte SSPSTAT= 0xfc7 
.................... #byte SSPCON1= 0xfc6 
.................... #byte SSPCON2= 0xfc5 
....................  
.................... #bit  SSPIF= PIR1.3 
.................... #bit  WCOL= SSPCON1.3 
.................... //============================================================================== 
.................... // These are some colors that you can use for fonts and graphics. 
.................... //==============================================================================                         // RRRRRGGGGGGBBBBB 
.................... #define BLACK              0b0000000000000000 
.................... #define BRIGHTBLUE         0b0000000000011111 
.................... #define BRIGHTGREEN        0b0000011111100000 
.................... #define BRIGHTCYAN         0b0000011111111111 
.................... #define BRIGHTRED          0b1111100000000000 
.................... #define BRIGHTMAGENTA      0b1111100000011111 
.................... #define BRIGHTYELLOW       0b1111111111100000 
.................... #define BLUE               0b0000000000010000 
.................... #define GREEN              0b0000010000000000 
.................... #define CYAN               0b0000010000010000 
.................... #define RED                0b1000000000000000 
.................... #define MAGENTA            0b1000000000010000 
.................... #define BROWN              0b1111110000000000 
.................... #define LIGHTGRAY          0b1000010000010000 
.................... #define DARKGRAY           0b0100001000001000 
.................... #define LIGHTBLUE          0b1000010000011111 
.................... #define LIGHTGREEN         0b1000011111110000 
.................... #define LIGHTCYAN          0b1000011111111111 
.................... #define LIGHTRED           0b1111110000010000 
.................... #define LIGHTMAGENTA       0b1111110000011111 
.................... #define YELLOW             0b1111111000000000 
.................... #define WHITE              0b1111111111111111 
....................  
.................... #define GRAY0              0b1110011100011100 
.................... #define GRAY1              0b1100011000011000    
.................... #define GRAY2              0b1010010100010100    
.................... #define GRAY3              0b1000010000010000 
.................... #define GRAY4              0b0110001100001100 
.................... #define GRAY5              0b0100001000001000 
.................... #define GRAY6              0b0010000100000100 
....................  
....................  
.................... //============================================================================== 
.................... // Define number of pixels in width and height. 
.................... // New name for data types. 
.................... //============================================================================== 
.................... #define TFT_W 240 
.................... #define TFT_H 320 
....................  
.................... //============================================================================== 
.................... // Sampling Size to fix touch value. 
.................... //============================================================================== 
.................... #define SMPLSIZE 10 
....................  
.................... //============================================================================== 
.................... // Function Prototypes. 
.................... //============================================================================== 
.................... signed char WriteSPI(unsigned char data); 
.................... void TFT_Init(void); 
.................... void TFT_Reset(void); 
.................... void TFT_Delay(void); 
.................... void TFT_WriteCommand(Unsigned char command); 
.................... void TFT_WriteParameter(Unsigned char parameter); 
.................... void TFT_FillScreen(Unsigned long color); 
.................... void TFT_ColumnRow(Unsigned int16 x, Unsigned int16 y); 
.................... void TFT_ColumnPage(Unsigned int16 x1, Unsigned int16 x2, Unsigned int16 y1, Unsigned int16 y2); 
.................... unsigned int16 TFT_RGBConvert(Unsigned int16 red8, Unsigned int16 green8, Unsigned int16 blue8); 
.................... //------------------------------------------------------------------------------ 
.................... void TFT_Pixel(Unsigned int16 x, Unsigned int16 y, Unsigned int16 color); 
.................... void TFT_Box(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Line(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Rectangle(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Circle(unsigned int16 SX, unsigned int16 SY, unsigned int16 Radius,unsigned int16 Fill, unsigned int16 Color); 
.................... void test_drawing(void); 
....................  
.................... void touch_init(void); 
.................... int16 Read_X(void); 
.................... int16 Read_Y(void); 
.................... unsigned int16 convert_X(unsigned int16 X); 
.................... unsigned int16 convert_Y(unsigned int16 Y); 
.................... signed int16 get_touch_Xval(signed int16* X_val); 
.................... signed int16 get_touch_Yval(signed int16* Y_val); 
.................... #endif 
....................  
.................... #include "mTFT.c" 
....................  
.................... #include "mTFT.h" 
.................... #ifndef __ILI9341_H 
.................... #define __ILI9341_H 
....................  
.................... //============================================================================== 
.................... //============================================================================== 
.................... //============================================================================== 
....................  
.................... #byte TRISC = 0xF94 
.................... #byte TRISD = 0xF95 
....................  
.................... #byte PORTC = 0xF82 
.................... #byte PORTD = 0xF83 
....................  
.................... #bit  SDO=PORTC.5 
.................... #bit  SDI=PORTC.4 
.................... #bit  SCK=PORTC.3 
....................  
.................... #bit  TRIS_SDO=TRISC.5 
.................... #bit  TRIS_SDI=TRISC.4 
.................... #bit  TRIS_SCK=TRISC.3 
....................  
....................  
.................... #define pl() printf("LINE=%d\n",__LINE__); 
.................... //============================================================================== 
.................... // Connection of module TFT. 
.................... // 
.................... // VCC      <<<>>> 5 V. 
.................... // GND      <<<>>> GND. 
.................... // TFT_CS   <<<>>> PORTD.0 You can change this pin. 
.................... // TFT_REST <<<>>> PORTD.1 You can change this pin. 
.................... // TFT_D/C  <<<>>> PORTD.2 You can change this pin. 
.................... // TFT_SDI  <<<>>> Connect to SDO MCU. 
.................... // TFT_SCK  <<<>>> Connect to SCK MCU. 
.................... // TFT_SDO  <<<>>> Connect to SDI MCU. 
.................... // 
.................... //============================================================================== 
.................... #byte TRISD = 0xF95 
.................... #byte PORTD = 0xF83 
....................  
.................... #bit  TFT_CS=PORTD.0 
.................... #bit  TRIS_CS=TRISD.0 
....................  
.................... #bit  TFT_RES=PORTD.1 
.................... #bit  TRIS_RES=TRISD.1 
....................  
.................... #bit  TFT_DC=PORTD.2 
.................... #bit  TRIS_DC=TRISD.2 
....................  
.................... //============================================================================== 
.................... // Connection of MCP3202. 
.................... // 
.................... // VCC      <<<>>> 5 V. 
.................... // GND      <<<>>> GND. 
.................... // MCP_CS   <<<>>> PORTD.3 You can change this pin. 
.................... // CH0      <<<>>> Y+ 
.................... // CH1      <<<>>> X+ 
.................... // MCP_SDI  <<<>>> Connect to SDO MCU. 
.................... // MCP_SCK  <<<>>> Connect to SCK MCU. 
.................... // MCP_SDO  <<<>>> Connect to SDI MCU. 
.................... //  
.................... //============================================================================== 
....................  
.................... #bit TRIS_Yp = TRISD.7 
.................... #bit TRIS_Xp = TRISD.6 
.................... #bit TRIS_Ym = TRISD.5 
.................... #bit TRIS_Xm = TRISD.4 
....................  
.................... #bit TRIS_TS_CS = TRISD.3 
.................... #bit TS_CS = PORTD.3 
....................  
.................... #bit Yp = PORTD.7 
.................... #bit Xp = PORTD.6 
.................... #bit Ym = PORTD.5 
.................... #bit Xm = PORTD.4 
....................  
.................... //============================================================================== 
.................... //============================================================================== 
.................... #byte INTCON=0xFF2 
.................... #byte PIE1=0xF9D 
.................... #byte PIR1 = 0xf9e 
....................  
.................... #byte SSPBRG= 0xfaf 
.................... #byte SSPBUF= 0xfc9 
.................... #byte SSPADD= 0xfc8 
.................... #byte SSPSTAT= 0xfc7 
.................... #byte SSPCON1= 0xfc6 
.................... #byte SSPCON2= 0xfc5 
....................  
.................... #bit  SSPIF= PIR1.3 
.................... #bit  WCOL= SSPCON1.3 
.................... //============================================================================== 
.................... // These are some colors that you can use for fonts and graphics. 
.................... //==============================================================================                         // RRRRRGGGGGGBBBBB 
.................... #define BLACK              0b0000000000000000 
.................... #define BRIGHTBLUE         0b0000000000011111 
.................... #define BRIGHTGREEN        0b0000011111100000 
.................... #define BRIGHTCYAN         0b0000011111111111 
.................... #define BRIGHTRED          0b1111100000000000 
.................... #define BRIGHTMAGENTA      0b1111100000011111 
.................... #define BRIGHTYELLOW       0b1111111111100000 
.................... #define BLUE               0b0000000000010000 
.................... #define GREEN              0b0000010000000000 
.................... #define CYAN               0b0000010000010000 
.................... #define RED                0b1000000000000000 
.................... #define MAGENTA            0b1000000000010000 
.................... #define BROWN              0b1111110000000000 
.................... #define LIGHTGRAY          0b1000010000010000 
.................... #define DARKGRAY           0b0100001000001000 
.................... #define LIGHTBLUE          0b1000010000011111 
.................... #define LIGHTGREEN         0b1000011111110000 
.................... #define LIGHTCYAN          0b1000011111111111 
.................... #define LIGHTRED           0b1111110000010000 
.................... #define LIGHTMAGENTA       0b1111110000011111 
.................... #define YELLOW             0b1111111000000000 
.................... #define WHITE              0b1111111111111111 
....................  
.................... #define GRAY0              0b1110011100011100 
.................... #define GRAY1              0b1100011000011000    
.................... #define GRAY2              0b1010010100010100    
.................... #define GRAY3              0b1000010000010000 
.................... #define GRAY4              0b0110001100001100 
.................... #define GRAY5              0b0100001000001000 
.................... #define GRAY6              0b0010000100000100 
....................  
....................  
.................... //============================================================================== 
.................... // Define number of pixels in width and height. 
.................... // New name for data types. 
.................... //============================================================================== 
.................... #define TFT_W 240 
.................... #define TFT_H 320 
....................  
.................... //============================================================================== 
.................... // Sampling Size to fix touch value. 
.................... //============================================================================== 
.................... #define SMPLSIZE 10 
....................  
.................... //============================================================================== 
.................... // Function Prototypes. 
.................... //============================================================================== 
.................... signed char WriteSPI(unsigned char data); 
.................... void TFT_Init(void); 
.................... void TFT_Reset(void); 
.................... void TFT_Delay(void); 
.................... void TFT_WriteCommand(Unsigned char command); 
.................... void TFT_WriteParameter(Unsigned char parameter); 
.................... void TFT_FillScreen(Unsigned long color); 
.................... void TFT_ColumnRow(Unsigned int16 x, Unsigned int16 y); 
.................... void TFT_ColumnPage(Unsigned int16 x1, Unsigned int16 x2, Unsigned int16 y1, Unsigned int16 y2); 
.................... unsigned int16 TFT_RGBConvert(Unsigned int16 red8, Unsigned int16 green8, Unsigned int16 blue8); 
.................... //------------------------------------------------------------------------------ 
.................... void TFT_Pixel(Unsigned int16 x, Unsigned int16 y, Unsigned int16 color); 
.................... void TFT_Box(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Line(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Rectangle(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color); 
.................... void TFT_Circle(unsigned int16 SX, unsigned int16 SY, unsigned int16 Radius,unsigned int16 Fill, unsigned int16 Color); 
.................... void test_drawing(void); 
....................  
.................... void touch_init(void); 
.................... int16 Read_X(void); 
.................... int16 Read_Y(void); 
.................... unsigned int16 convert_X(unsigned int16 X); 
.................... unsigned int16 convert_Y(unsigned int16 Y); 
.................... signed int16 get_touch_Xval(signed int16* X_val); 
.................... signed int16 get_touch_Yval(signed int16* Y_val); 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
*
1D18:  MOVFF  7F,8D
1D1C:  MOVFF  7E,8C
1D20:  MOVFF  7D,8B
1D24:  MOVFF  7C,8A
1D28:  CLRF   x91
1D2A:  CLRF   x90
1D2C:  CLRF   x8F
1D2E:  CLRF   x8E
1D30:  CALL   1014
1D34:  BC    1D38
1D36:  BNZ   1D42
....................       return(0.0); 
1D38:  CLRF   00
1D3A:  CLRF   01
1D3C:  CLRF   02
1D3E:  CLRF   03
1D40:  BRA    1E28
....................  
....................    y=x; 
1D42:  MOVFF  7F,83
1D46:  MOVFF  7E,82
1D4A:  MOVFF  7D,81
1D4E:  MOVFF  7C,80
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
1D52:  CLRF   x89
1D54:  MOVLW  80
1D56:  MOVWF  x88
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
1D58:  MOVFF  88,FE9
1D5C:  MOVFF  89,FEA
1D60:  MOVF   FEF,W
1D62:  CLRF   x8D
1D64:  MOVWF  x8C
1D66:  MOVLW  7F
1D68:  ADDWF  x8C,F
1D6A:  MOVLW  00
1D6C:  ADDWFC x8D,F
1D6E:  BCF    FD8.0
1D70:  RRCF   x8D,W
1D72:  RRCF   x8C,W
1D74:  MOVFF  89,FEA
1D78:  MOVFF  88,FE9
1D7C:  MOVWF  FEF
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
1D7E:  MOVFF  83,87
1D82:  MOVFF  82,86
1D86:  MOVFF  81,85
1D8A:  MOVFF  80,84
....................       y+=(x/y); 
1D8E:  MOVFF  7F,8D
1D92:  MOVFF  7E,8C
1D96:  MOVFF  7D,8B
1D9A:  MOVFF  7C,8A
1D9E:  MOVFF  83,91
1DA2:  MOVFF  82,90
1DA6:  MOVFF  81,8F
1DAA:  MOVFF  80,8E
1DAE:  CALL   132C
1DB2:  BCF    FD8.1
1DB4:  MOVFF  83,8D
1DB8:  MOVFF  82,8C
1DBC:  MOVFF  81,8B
1DC0:  MOVFF  80,8A
1DC4:  MOVFF  03,91
1DC8:  MOVFF  02,90
1DCC:  MOVFF  01,8F
1DD0:  MOVFF  00,8E
1DD4:  CALL   108A
1DD8:  MOVFF  03,83
1DDC:  MOVFF  02,82
1DE0:  MOVFF  01,81
1DE4:  MOVFF  00,80
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
1DE8:  MOVFF  88,FE9
1DEC:  MOVFF  89,FEA
1DF0:  DECF   FEF,F
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
1DF2:  MOVFF  87,8D
1DF6:  MOVFF  86,8C
1DFA:  MOVFF  85,8B
1DFE:  MOVFF  84,8A
1E02:  MOVFF  83,91
1E06:  MOVFF  82,90
1E0A:  MOVFF  81,8F
1E0E:  MOVFF  80,8E
1E12:  CALL   1014
1E16:  BNZ   1D7E
....................  
....................    return(res); 
1E18:  MOVFF  84,00
1E1C:  MOVFF  85,01
1E20:  MOVFF  86,02
1E24:  MOVFF  87,03
.................... } 
1E28:  GOTO   21CE (RETURN)
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #use delay(clock=20000000) 
*
0524:  CLRF   FEA
0526:  MOVLW  67
0528:  MOVWF  FE9
052A:  MOVF   FEF,W
052C:  BZ    0548
052E:  MOVLW  06
0530:  MOVWF  01
0532:  CLRF   00
0534:  DECFSZ 00,F
0536:  BRA    0534
0538:  DECFSZ 01,F
053A:  BRA    0532
053C:  MOVLW  7B
053E:  MOVWF  00
0540:  DECFSZ 00,F
0542:  BRA    0540
0544:  DECFSZ FEF,F
0546:  BRA    052E
0548:  GOTO   055A (RETURN)
.................... //============================================================================== 
.................... // make WriteSPI 
.................... //============================================================================== 
....................  
.................... signed char WriteSPI( unsigned char data_out ) 
.................... { 
....................   unsigned char TempVar;   
....................   TempVar = SSPBUF;           // Clears BF 
*
02BA:  MOVFF  FC9,CD
....................   SSPIF = 0;                  // Clear interrupt flag 
02BE:  BCF    F9E.3
....................   WCOL = 0;                   //Clear any previous write collision 
02C0:  BCF    FC6.3
....................   SSPBUF = data_out;           // write byte to SSPBUF register 
02C2:  MOVFF  CC,FC9
....................   if ( SSPCON1 & 0x80 )        // test if write collision occurred 
02C6:  BTFSS  FC6.7
02C8:  BRA    02D2
....................    return ( -1 );              // if WCOL bit is set return negative # 
02CA:  MOVLW  FF
02CC:  MOVWF  01
02CE:  BRA    02DA
....................   else 
02D0:  BRA    02D6
....................     while( !SSPIF );             // wait until bus cycle complete   
02D2:  BTFSS  F9E.3
02D4:  BRA    02D2
....................    return 0 ;                // if WCOL bit is not set return non-negative# 
02D6:  MOVLW  00
02D8:  MOVWF  01
.................... } 
02DA:  RETURN 0
.................... //============================================================================== 
.................... // Initializes the TFT module. 
.................... //============================================================================== 
.................... void TFT_Init(void) 
.................... { 
....................    TRIS_CS = 0; TRIS_DC = 0; TRIS_RES = 0; 
*
05F6:  BCF    F95.0
05F8:  BCF    F95.2
05FA:  BCF    F95.1
....................    TFT_CS = 1; TFT_DC = 0; TFT_RES = 0; 
05FC:  BSF    F83.0
05FE:  BCF    F83.2
0600:  BCF    F83.1
....................    TFT_Reset(); 
0602:  BRA    0560
0604:  CLRF   19
0606:  BTFSC  FF2.7
0608:  BSF    19.7
060A:  BCF    FF2.7
....................    TFT_WriteCommand(0xCB);   // Power control A (CBh) 
060C:  MOVLW  CB
060E:  MOVWF  xC9
0610:  RCALL  02DC
0612:  BTFSC  19.7
0614:  BSF    FF2.7
0616:  CLRF   19
0618:  BTFSC  FF2.7
061A:  BSF    19.7
061C:  BCF    FF2.7
....................    TFT_WriteParameter(0x39);  
061E:  MOVLW  39
0620:  MOVWF  xCB
0622:  RCALL  02F0
0624:  BTFSC  19.7
0626:  BSF    FF2.7
0628:  CLRF   19
062A:  BTFSC  FF2.7
062C:  BSF    19.7
062E:  BCF    FF2.7
....................    TFT_WriteParameter(0x2C);  
0630:  MOVLW  2C
0632:  MOVWF  xCB
0634:  RCALL  02F0
0636:  BTFSC  19.7
0638:  BSF    FF2.7
063A:  CLRF   19
063C:  BTFSC  FF2.7
063E:  BSF    19.7
0640:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0642:  CLRF   xCB
0644:  RCALL  02F0
0646:  BTFSC  19.7
0648:  BSF    FF2.7
064A:  CLRF   19
064C:  BTFSC  FF2.7
064E:  BSF    19.7
0650:  BCF    FF2.7
....................    TFT_WriteParameter(0x34);  
0652:  MOVLW  34
0654:  MOVWF  xCB
0656:  RCALL  02F0
0658:  BTFSC  19.7
065A:  BSF    FF2.7
065C:  CLRF   19
065E:  BTFSC  FF2.7
0660:  BSF    19.7
0662:  BCF    FF2.7
....................    TFT_WriteParameter(0x02);  
0664:  MOVLW  02
0666:  MOVWF  xCB
0668:  RCALL  02F0
066A:  BTFSC  19.7
066C:  BSF    FF2.7
066E:  CLRF   19
0670:  BTFSC  FF2.7
0672:  BSF    19.7
0674:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xCF);   // Power control B (CFh) 
0676:  MOVLW  CF
0678:  MOVWF  xC9
067A:  RCALL  02DC
067C:  BTFSC  19.7
067E:  BSF    FF2.7
0680:  CLRF   19
0682:  BTFSC  FF2.7
0684:  BSF    19.7
0686:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0688:  CLRF   xCB
068A:  RCALL  02F0
068C:  BTFSC  19.7
068E:  BSF    FF2.7
0690:  CLRF   19
0692:  BTFSC  FF2.7
0694:  BSF    19.7
0696:  BCF    FF2.7
....................    TFT_WriteParameter(0XC1);  
0698:  MOVLW  C1
069A:  MOVWF  xCB
069C:  RCALL  02F0
069E:  BTFSC  19.7
06A0:  BSF    FF2.7
06A2:  CLRF   19
06A4:  BTFSC  FF2.7
06A6:  BSF    19.7
06A8:  BCF    FF2.7
....................    TFT_WriteParameter(0X30);  
06AA:  MOVLW  30
06AC:  MOVWF  xCB
06AE:  RCALL  02F0
06B0:  BTFSC  19.7
06B2:  BSF    FF2.7
06B4:  CLRF   19
06B6:  BTFSC  FF2.7
06B8:  BSF    19.7
06BA:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xE8);   // Driver timing control A (E8h)   
06BC:  MOVLW  E8
06BE:  MOVWF  xC9
06C0:  RCALL  02DC
06C2:  BTFSC  19.7
06C4:  BSF    FF2.7
06C6:  CLRF   19
06C8:  BTFSC  FF2.7
06CA:  BSF    19.7
06CC:  BCF    FF2.7
....................    TFT_WriteParameter(0x85);  
06CE:  MOVLW  85
06D0:  MOVWF  xCB
06D2:  RCALL  02F0
06D4:  BTFSC  19.7
06D6:  BSF    FF2.7
06D8:  CLRF   19
06DA:  BTFSC  FF2.7
06DC:  BSF    19.7
06DE:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
06E0:  CLRF   xCB
06E2:  RCALL  02F0
06E4:  BTFSC  19.7
06E6:  BSF    FF2.7
06E8:  CLRF   19
06EA:  BTFSC  FF2.7
06EC:  BSF    19.7
06EE:  BCF    FF2.7
....................    TFT_WriteParameter(0x78);  
06F0:  MOVLW  78
06F2:  MOVWF  xCB
06F4:  RCALL  02F0
06F6:  BTFSC  19.7
06F8:  BSF    FF2.7
06FA:  CLRF   19
06FC:  BTFSC  FF2.7
06FE:  BSF    19.7
0700:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xEA);   // Driver timing control B (EAh)   
0702:  MOVLW  EA
0704:  MOVWF  xC9
0706:  RCALL  02DC
0708:  BTFSC  19.7
070A:  BSF    FF2.7
070C:  CLRF   19
070E:  BTFSC  FF2.7
0710:  BSF    19.7
0712:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0714:  CLRF   xCB
0716:  RCALL  02F0
0718:  BTFSC  19.7
071A:  BSF    FF2.7
071C:  CLRF   19
071E:  BTFSC  FF2.7
0720:  BSF    19.7
0722:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0724:  CLRF   xCB
0726:  RCALL  02F0
0728:  BTFSC  19.7
072A:  BSF    FF2.7
072C:  CLRF   19
072E:  BTFSC  FF2.7
0730:  BSF    19.7
0732:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xED);   // Power on sequence control (EDh)  
0734:  MOVLW  ED
0736:  MOVWF  xC9
0738:  RCALL  02DC
073A:  BTFSC  19.7
073C:  BSF    FF2.7
073E:  CLRF   19
0740:  BTFSC  FF2.7
0742:  BSF    19.7
0744:  BCF    FF2.7
....................    TFT_WriteParameter(0x64);  
0746:  MOVLW  64
0748:  MOVWF  xCB
074A:  RCALL  02F0
074C:  BTFSC  19.7
074E:  BSF    FF2.7
0750:  CLRF   19
0752:  BTFSC  FF2.7
0754:  BSF    19.7
0756:  BCF    FF2.7
....................    TFT_WriteParameter(0x03);  
0758:  MOVLW  03
075A:  MOVWF  xCB
075C:  RCALL  02F0
075E:  BTFSC  19.7
0760:  BSF    FF2.7
0762:  CLRF   19
0764:  BTFSC  FF2.7
0766:  BSF    19.7
0768:  BCF    FF2.7
....................    TFT_WriteParameter(0X12);  
076A:  MOVLW  12
076C:  MOVWF  xCB
076E:  RCALL  02F0
0770:  BTFSC  19.7
0772:  BSF    FF2.7
0774:  CLRF   19
0776:  BTFSC  FF2.7
0778:  BSF    19.7
077A:  BCF    FF2.7
....................    TFT_WriteParameter(0X81);  
077C:  MOVLW  81
077E:  MOVWF  xCB
0780:  RCALL  02F0
0782:  BTFSC  19.7
0784:  BSF    FF2.7
0786:  CLRF   19
0788:  BTFSC  FF2.7
078A:  BSF    19.7
078C:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xF7);   // Pump ratio control (F7h) 
078E:  MOVLW  F7
0790:  MOVWF  xC9
0792:  RCALL  02DC
0794:  BTFSC  19.7
0796:  BSF    FF2.7
0798:  CLRF   19
079A:  BTFSC  FF2.7
079C:  BSF    19.7
079E:  BCF    FF2.7
....................    TFT_WriteParameter(0x20);  
07A0:  MOVLW  20
07A2:  MOVWF  xCB
07A4:  RCALL  02F0
07A6:  BTFSC  19.7
07A8:  BSF    FF2.7
07AA:  CLRF   19
07AC:  BTFSC  FF2.7
07AE:  BSF    19.7
07B0:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xC0);   // Power Control 1 (C0h)  
07B2:  MOVLW  C0
07B4:  MOVWF  xC9
07B6:  RCALL  02DC
07B8:  BTFSC  19.7
07BA:  BSF    FF2.7
07BC:  CLRF   19
07BE:  BTFSC  FF2.7
07C0:  BSF    19.7
07C2:  BCF    FF2.7
....................    TFT_WriteParameter(0x23); // VRH[5:0]  
07C4:  MOVLW  23
07C6:  MOVWF  xCB
07C8:  RCALL  02F0
07CA:  BTFSC  19.7
07CC:  BSF    FF2.7
07CE:  CLRF   19
07D0:  BTFSC  FF2.7
07D2:  BSF    19.7
07D4:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xC1);   // Power Control 2 (C1h) 
07D6:  MOVLW  C1
07D8:  MOVWF  xC9
07DA:  RCALL  02DC
07DC:  BTFSC  19.7
07DE:  BSF    FF2.7
07E0:  CLRF   19
07E2:  BTFSC  FF2.7
07E4:  BSF    19.7
07E6:  BCF    FF2.7
....................    TFT_WriteParameter(0x10); // SAP[2:0]; BT[3:0]  
07E8:  MOVLW  10
07EA:  MOVWF  xCB
07EC:  RCALL  02F0
07EE:  BTFSC  19.7
07F0:  BSF    FF2.7
07F2:  CLRF   19
07F4:  BTFSC  FF2.7
07F6:  BSF    19.7
07F8:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xC5);   // Set the VCOMH voltage.  
07FA:  MOVLW  C5
07FC:  MOVWF  xC9
07FE:  RCALL  02DC
0800:  BTFSC  19.7
0802:  BSF    FF2.7
0804:  CLRF   19
0806:  BTFSC  FF2.7
0808:  BSF    19.7
080A:  BCF    FF2.7
....................    TFT_WriteParameter(0x3E); 
080C:  MOVLW  3E
080E:  MOVWF  xCB
0810:  RCALL  02F0
0812:  BTFSC  19.7
0814:  BSF    FF2.7
0816:  CLRF   19
0818:  BTFSC  FF2.7
081A:  BSF    19.7
081C:  BCF    FF2.7
....................    TFT_WriteParameter(0x28);  
081E:  MOVLW  28
0820:  MOVWF  xCB
0822:  RCALL  02F0
0824:  BTFSC  19.7
0826:  BSF    FF2.7
0828:  CLRF   19
082A:  BTFSC  FF2.7
082C:  BSF    19.7
082E:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xC7);   // VCOM Control 2(C7h) 
0830:  MOVLW  C7
0832:  MOVWF  xC9
0834:  RCALL  02DC
0836:  BTFSC  19.7
0838:  BSF    FF2.7
083A:  CLRF   19
083C:  BTFSC  FF2.7
083E:  BSF    19.7
0840:  BCF    FF2.7
....................    TFT_WriteParameter(0x86);   
0842:  MOVLW  86
0844:  MOVWF  xCB
0846:  RCALL  02F0
0848:  BTFSC  19.7
084A:  BSF    FF2.7
084C:  CLRF   19
084E:  BTFSC  FF2.7
0850:  BSF    19.7
0852:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0x36);   // Memory Access Control (36h) 
0854:  MOVLW  36
0856:  MOVWF  xC9
0858:  RCALL  02DC
085A:  BTFSC  19.7
085C:  BSF    FF2.7
085E:  CLRF   19
0860:  BTFSC  FF2.7
0862:  BSF    19.7
0864:  BCF    FF2.7
....................    //TFT_WriteParameter(0x48);   // Memory Access Control (36h) 
....................    TFT_WriteParameter(0b10001000);  
0866:  MOVLW  88
0868:  MOVWF  xCB
086A:  RCALL  02F0
086C:  BTFSC  19.7
086E:  BSF    FF2.7
0870:  CLRF   19
0872:  BTFSC  FF2.7
0874:  BSF    19.7
0876:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0x3A);   // COLMOD: Pixel Format Set (3Ah)     
0878:  MOVLW  3A
087A:  MOVWF  xC9
087C:  RCALL  02DC
087E:  BTFSC  19.7
0880:  BSF    FF2.7
0882:  CLRF   19
0884:  BTFSC  FF2.7
0886:  BSF    19.7
0888:  BCF    FF2.7
....................    TFT_WriteParameter(0x55);  
088A:  MOVLW  55
088C:  MOVWF  xCB
088E:  RCALL  02F0
0890:  BTFSC  19.7
0892:  BSF    FF2.7
0894:  CLRF   19
0896:  BTFSC  FF2.7
0898:  BSF    19.7
089A:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xB1);   // Frame Rate Control (In Normal Mode/Full Colors) (B1h)   
089C:  MOVLW  B1
089E:  MOVWF  xC9
08A0:  RCALL  02DC
08A2:  BTFSC  19.7
08A4:  BSF    FF2.7
08A6:  CLRF   19
08A8:  BTFSC  FF2.7
08AA:  BSF    19.7
08AC:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);   
08AE:  CLRF   xCB
08B0:  RCALL  02F0
08B2:  BTFSC  19.7
08B4:  BSF    FF2.7
08B6:  CLRF   19
08B8:  BTFSC  FF2.7
08BA:  BSF    19.7
08BC:  BCF    FF2.7
....................    TFT_WriteParameter(0x18);  
08BE:  MOVLW  18
08C0:  MOVWF  xCB
08C2:  RCALL  02F0
08C4:  BTFSC  19.7
08C6:  BSF    FF2.7
08C8:  CLRF   19
08CA:  BTFSC  FF2.7
08CC:  BSF    19.7
08CE:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xB6);   // Display Function Control (B6h)  
08D0:  MOVLW  B6
08D2:  MOVWF  xC9
08D4:  RCALL  02DC
08D6:  BTFSC  19.7
08D8:  BSF    FF2.7
08DA:  CLRF   19
08DC:  BTFSC  FF2.7
08DE:  BSF    19.7
08E0:  BCF    FF2.7
....................    TFT_WriteParameter(0x08);  
08E2:  MOVLW  08
08E4:  MOVWF  xCB
08E6:  RCALL  02F0
08E8:  BTFSC  19.7
08EA:  BSF    FF2.7
08EC:  CLRF   19
08EE:  BTFSC  FF2.7
08F0:  BSF    19.7
08F2:  BCF    FF2.7
....................    TFT_WriteParameter(0x82); 
08F4:  MOVLW  82
08F6:  MOVWF  xCB
08F8:  RCALL  02F0
08FA:  BTFSC  19.7
08FC:  BSF    FF2.7
08FE:  CLRF   19
0900:  BTFSC  FF2.7
0902:  BSF    19.7
0904:  BCF    FF2.7
....................    TFT_WriteParameter(0x27);   
0906:  MOVLW  27
0908:  MOVWF  xCB
090A:  RCALL  02F0
090C:  BTFSC  19.7
090E:  BSF    FF2.7
0910:  CLRF   19
0912:  BTFSC  FF2.7
0914:  BSF    19.7
0916:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xF2);   // Enable 3G (F2h) 
0918:  MOVLW  F2
091A:  MOVWF  xC9
091C:  RCALL  02DC
091E:  BTFSC  19.7
0920:  BSF    FF2.7
0922:  CLRF   19
0924:  BTFSC  FF2.7
0926:  BSF    19.7
0928:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
092A:  CLRF   xCB
092C:  RCALL  02F0
092E:  BTFSC  19.7
0930:  BSF    FF2.7
0932:  CLRF   19
0934:  BTFSC  FF2.7
0936:  BSF    19.7
0938:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0x26);   // Gamma Set (26h) 
093A:  MOVLW  26
093C:  MOVWF  xC9
093E:  RCALL  02DC
0940:  BTFSC  19.7
0942:  BSF    FF2.7
0944:  CLRF   19
0946:  BTFSC  FF2.7
0948:  BSF    19.7
094A:  BCF    FF2.7
....................    TFT_WriteParameter(0x01);  
094C:  MOVLW  01
094E:  MOVWF  xCB
0950:  RCALL  02F0
0952:  BTFSC  19.7
0954:  BSF    FF2.7
0956:  CLRF   19
0958:  BTFSC  FF2.7
095A:  BSF    19.7
095C:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0xE0);   //Positive Gamma Correction (E0h) 
095E:  MOVLW  E0
0960:  MOVWF  xC9
0962:  RCALL  02DC
0964:  BTFSC  19.7
0966:  BSF    FF2.7
0968:  CLRF   19
096A:  BTFSC  FF2.7
096C:  BSF    19.7
096E:  BCF    FF2.7
....................    TFT_WriteParameter(0x0F);  
0970:  MOVLW  0F
0972:  MOVWF  xCB
0974:  RCALL  02F0
0976:  BTFSC  19.7
0978:  BSF    FF2.7
097A:  CLRF   19
097C:  BTFSC  FF2.7
097E:  BSF    19.7
0980:  BCF    FF2.7
....................    TFT_WriteParameter(0x31);  
0982:  MOVLW  31
0984:  MOVWF  xCB
0986:  RCALL  02F0
0988:  BTFSC  19.7
098A:  BSF    FF2.7
098C:  CLRF   19
098E:  BTFSC  FF2.7
0990:  BSF    19.7
0992:  BCF    FF2.7
....................    TFT_WriteParameter(0x2B);  
0994:  MOVLW  2B
0996:  MOVWF  xCB
0998:  RCALL  02F0
099A:  BTFSC  19.7
099C:  BSF    FF2.7
099E:  CLRF   19
09A0:  BTFSC  FF2.7
09A2:  BSF    19.7
09A4:  BCF    FF2.7
....................    TFT_WriteParameter(0x0C);  
09A6:  MOVLW  0C
09A8:  MOVWF  xCB
09AA:  RCALL  02F0
09AC:  BTFSC  19.7
09AE:  BSF    FF2.7
09B0:  CLRF   19
09B2:  BTFSC  FF2.7
09B4:  BSF    19.7
09B6:  BCF    FF2.7
....................    TFT_WriteParameter(0x0E);  
09B8:  MOVLW  0E
09BA:  MOVWF  xCB
09BC:  RCALL  02F0
09BE:  BTFSC  19.7
09C0:  BSF    FF2.7
09C2:  CLRF   19
09C4:  BTFSC  FF2.7
09C6:  BSF    19.7
09C8:  BCF    FF2.7
....................    TFT_WriteParameter(0x08);  
09CA:  MOVLW  08
09CC:  MOVWF  xCB
09CE:  RCALL  02F0
09D0:  BTFSC  19.7
09D2:  BSF    FF2.7
09D4:  CLRF   19
09D6:  BTFSC  FF2.7
09D8:  BSF    19.7
09DA:  BCF    FF2.7
....................    TFT_WriteParameter(0x4E);  
09DC:  MOVLW  4E
09DE:  MOVWF  xCB
09E0:  RCALL  02F0
09E2:  BTFSC  19.7
09E4:  BSF    FF2.7
09E6:  CLRF   19
09E8:  BTFSC  FF2.7
09EA:  BSF    19.7
09EC:  BCF    FF2.7
....................    TFT_WriteParameter(0xF1);  
09EE:  MOVLW  F1
09F0:  MOVWF  xCB
09F2:  RCALL  02F0
09F4:  BTFSC  19.7
09F6:  BSF    FF2.7
09F8:  CLRF   19
09FA:  BTFSC  FF2.7
09FC:  BSF    19.7
09FE:  BCF    FF2.7
....................    TFT_WriteParameter(0x37);  
0A00:  MOVLW  37
0A02:  MOVWF  xCB
0A04:  RCALL  02F0
0A06:  BTFSC  19.7
0A08:  BSF    FF2.7
0A0A:  CLRF   19
0A0C:  BTFSC  FF2.7
0A0E:  BSF    19.7
0A10:  BCF    FF2.7
....................    TFT_WriteParameter(0x07);  
0A12:  MOVLW  07
0A14:  MOVWF  xCB
0A16:  RCALL  02F0
0A18:  BTFSC  19.7
0A1A:  BSF    FF2.7
0A1C:  CLRF   19
0A1E:  BTFSC  FF2.7
0A20:  BSF    19.7
0A22:  BCF    FF2.7
....................    TFT_WriteParameter(0x10);  
0A24:  MOVLW  10
0A26:  MOVWF  xCB
0A28:  RCALL  02F0
0A2A:  BTFSC  19.7
0A2C:  BSF    FF2.7
0A2E:  CLRF   19
0A30:  BTFSC  FF2.7
0A32:  BSF    19.7
0A34:  BCF    FF2.7
....................    TFT_WriteParameter(0x03);  
0A36:  MOVLW  03
0A38:  MOVWF  xCB
0A3A:  RCALL  02F0
0A3C:  BTFSC  19.7
0A3E:  BSF    FF2.7
0A40:  CLRF   19
0A42:  BTFSC  FF2.7
0A44:  BSF    19.7
0A46:  BCF    FF2.7
....................    TFT_WriteParameter(0x0E);  
0A48:  MOVLW  0E
0A4A:  MOVWF  xCB
0A4C:  RCALL  02F0
0A4E:  BTFSC  19.7
0A50:  BSF    FF2.7
0A52:  CLRF   19
0A54:  BTFSC  FF2.7
0A56:  BSF    19.7
0A58:  BCF    FF2.7
....................    TFT_WriteParameter(0x09);  
0A5A:  MOVLW  09
0A5C:  MOVWF  xCB
0A5E:  RCALL  02F0
0A60:  BTFSC  19.7
0A62:  BSF    FF2.7
0A64:  CLRF   19
0A66:  BTFSC  FF2.7
0A68:  BSF    19.7
0A6A:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0A6C:  CLRF   xCB
0A6E:  RCALL  02F0
0A70:  BTFSC  19.7
0A72:  BSF    FF2.7
0A74:  CLRF   19
0A76:  BTFSC  FF2.7
0A78:  BSF    19.7
0A7A:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0XE1);   // Negative Gamma Correction (E1h) 
0A7C:  MOVLW  E1
0A7E:  MOVWF  xC9
0A80:  RCALL  02DC
0A82:  BTFSC  19.7
0A84:  BSF    FF2.7
0A86:  CLRF   19
0A88:  BTFSC  FF2.7
0A8A:  BSF    19.7
0A8C:  BCF    FF2.7
....................    TFT_WriteParameter(0x00);  
0A8E:  CLRF   xCB
0A90:  RCALL  02F0
0A92:  BTFSC  19.7
0A94:  BSF    FF2.7
0A96:  CLRF   19
0A98:  BTFSC  FF2.7
0A9A:  BSF    19.7
0A9C:  BCF    FF2.7
....................    TFT_WriteParameter(0x0E);  
0A9E:  MOVLW  0E
0AA0:  MOVWF  xCB
0AA2:  RCALL  02F0
0AA4:  BTFSC  19.7
0AA6:  BSF    FF2.7
0AA8:  CLRF   19
0AAA:  BTFSC  FF2.7
0AAC:  BSF    19.7
0AAE:  BCF    FF2.7
....................    TFT_WriteParameter(0x14);  
0AB0:  MOVLW  14
0AB2:  MOVWF  xCB
0AB4:  RCALL  02F0
0AB6:  BTFSC  19.7
0AB8:  BSF    FF2.7
0ABA:  CLRF   19
0ABC:  BTFSC  FF2.7
0ABE:  BSF    19.7
0AC0:  BCF    FF2.7
....................    TFT_WriteParameter(0x03);  
0AC2:  MOVLW  03
0AC4:  MOVWF  xCB
0AC6:  RCALL  02F0
0AC8:  BTFSC  19.7
0ACA:  BSF    FF2.7
0ACC:  CLRF   19
0ACE:  BTFSC  FF2.7
0AD0:  BSF    19.7
0AD2:  BCF    FF2.7
....................    TFT_WriteParameter(0x11);  
0AD4:  MOVLW  11
0AD6:  MOVWF  xCB
0AD8:  RCALL  02F0
0ADA:  BTFSC  19.7
0ADC:  BSF    FF2.7
0ADE:  CLRF   19
0AE0:  BTFSC  FF2.7
0AE2:  BSF    19.7
0AE4:  BCF    FF2.7
....................    TFT_WriteParameter(0x07);  
0AE6:  MOVLW  07
0AE8:  MOVWF  xCB
0AEA:  RCALL  02F0
0AEC:  BTFSC  19.7
0AEE:  BSF    FF2.7
0AF0:  CLRF   19
0AF2:  BTFSC  FF2.7
0AF4:  BSF    19.7
0AF6:  BCF    FF2.7
....................    TFT_WriteParameter(0x31);  
0AF8:  MOVLW  31
0AFA:  MOVWF  xCB
0AFC:  CALL   02F0
0B00:  BTFSC  19.7
0B02:  BSF    FF2.7
0B04:  CLRF   19
0B06:  BTFSC  FF2.7
0B08:  BSF    19.7
0B0A:  BCF    FF2.7
....................    TFT_WriteParameter(0xC1);  
0B0C:  MOVLW  C1
0B0E:  MOVWF  xCB
0B10:  CALL   02F0
0B14:  BTFSC  19.7
0B16:  BSF    FF2.7
0B18:  CLRF   19
0B1A:  BTFSC  FF2.7
0B1C:  BSF    19.7
0B1E:  BCF    FF2.7
....................    TFT_WriteParameter(0x48);  
0B20:  MOVLW  48
0B22:  MOVWF  xCB
0B24:  CALL   02F0
0B28:  BTFSC  19.7
0B2A:  BSF    FF2.7
0B2C:  CLRF   19
0B2E:  BTFSC  FF2.7
0B30:  BSF    19.7
0B32:  BCF    FF2.7
....................    TFT_WriteParameter(0x08);  
0B34:  MOVLW  08
0B36:  MOVWF  xCB
0B38:  CALL   02F0
0B3C:  BTFSC  19.7
0B3E:  BSF    FF2.7
0B40:  CLRF   19
0B42:  BTFSC  FF2.7
0B44:  BSF    19.7
0B46:  BCF    FF2.7
....................    TFT_WriteParameter(0x0F);  
0B48:  MOVLW  0F
0B4A:  MOVWF  xCB
0B4C:  CALL   02F0
0B50:  BTFSC  19.7
0B52:  BSF    FF2.7
0B54:  CLRF   19
0B56:  BTFSC  FF2.7
0B58:  BSF    19.7
0B5A:  BCF    FF2.7
....................    TFT_WriteParameter(0x0C);  
0B5C:  MOVLW  0C
0B5E:  MOVWF  xCB
0B60:  CALL   02F0
0B64:  BTFSC  19.7
0B66:  BSF    FF2.7
0B68:  CLRF   19
0B6A:  BTFSC  FF2.7
0B6C:  BSF    19.7
0B6E:  BCF    FF2.7
....................    TFT_WriteParameter(0x31);  
0B70:  MOVLW  31
0B72:  MOVWF  xCB
0B74:  CALL   02F0
0B78:  BTFSC  19.7
0B7A:  BSF    FF2.7
0B7C:  CLRF   19
0B7E:  BTFSC  FF2.7
0B80:  BSF    19.7
0B82:  BCF    FF2.7
....................    TFT_WriteParameter(0x36);  
0B84:  MOVLW  36
0B86:  MOVWF  xCB
0B88:  CALL   02F0
0B8C:  BTFSC  19.7
0B8E:  BSF    FF2.7
0B90:  CLRF   19
0B92:  BTFSC  FF2.7
0B94:  BSF    19.7
0B96:  BCF    FF2.7
....................    TFT_WriteParameter(0x0F);  
0B98:  MOVLW  0F
0B9A:  MOVWF  xCB
0B9C:  CALL   02F0
0BA0:  BTFSC  19.7
0BA2:  BSF    FF2.7
0BA4:  CLRF   19
0BA6:  BTFSC  FF2.7
0BA8:  BSF    19.7
0BAA:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0x11);    //Exit Sleep 
0BAC:  MOVLW  11
0BAE:  MOVWF  xC9
0BB0:  CALL   02DC
0BB4:  BTFSC  19.7
0BB6:  BSF    FF2.7
....................    TFT_Delay(); TFT_Delay(); TFT_Delay(); // Delay of 150ms 
0BB8:  RCALL  054C
0BBA:  RCALL  054C
0BBC:  RCALL  054C
0BBE:  CLRF   19
0BC0:  BTFSC  FF2.7
0BC2:  BSF    19.7
0BC4:  BCF    FF2.7
....................    TFT_WriteCommand(0x29);   // Display ON (29h) 
0BC6:  MOVLW  29
0BC8:  MOVWF  xC9
0BCA:  CALL   02DC
0BCE:  BTFSC  19.7
0BD0:  BSF    FF2.7
....................    TFT_FillScreen(WHITE); 
0BD2:  SETF   67
0BD4:  SETF   66
0BD6:  RCALL  0574
.................... } 
0BD8:  GOTO   229A (RETURN)
....................  
....................  
.................... //============================================================================== 
.................... // Resets the TFT module. 
.................... //============================================================================== 
.................... void TFT_Reset(void) 
.................... { 
....................    TS_CS=1; 
*
0560:  BSF    F83.3
....................    TFT_CS = 1;         
0562:  BSF    F83.0
....................    TFT_RES = 0; TFT_Delay(); 
0564:  BCF    F83.1
0566:  RCALL  054C
....................    TFT_RES = 1; TFT_Delay(); TFT_Delay(); TFT_Delay(); 
0568:  BSF    F83.1
056A:  RCALL  054C
056C:  RCALL  054C
056E:  RCALL  054C
.................... } 
0570:  GOTO   0604 (RETURN)
.................... //============================================================================== 
.................... // Delay for the TFT module. 
.................... //============================================================================== 
.................... void TFT_Delay(void) 
.................... { 
....................    Unsigned int i; 
....................    for(i = 0; i < 50; i++){ 
*
054C:  CLRF   66
054E:  MOVF   66,W
0550:  SUBLW  31
0552:  BNC   055E
....................       delay_ms(1); 
0554:  MOVLW  01
0556:  MOVWF  67
0558:  BRA    0524
....................    } 
055A:  INCF   66,F
055C:  BRA    054E
.................... } 
055E:  RETURN 0
....................  
.................... //============================================================================== 
.................... // Writes command. 
.................... //============================================================================== 
.................... void TFT_WriteCommand(Unsigned char command) 
.................... { 
....................    TS_CS=1; 
*
02DC:  BSF    F83.3
....................    TFT_CS = 0; 
02DE:  BCF    F83.0
....................    TFT_DC = 0;   //When DCX = ?? command is selected. 
02E0:  BCF    F83.2
....................    while(WriteSPI(command)); 
02E2:  MOVFF  C9,CC
02E6:  RCALL  02BA
02E8:  MOVF   01,F
02EA:  BNZ   02E2
....................    TFT_CS = 1; 
02EC:  BSF    F83.0
.................... } 
02EE:  RETURN 0
....................  
.................... //============================================================================== 
.................... // Writes Parameter. 
.................... //============================================================================== 
.................... void TFT_WriteParameter(Unsigned char parameter) 
.................... { 
....................    TS_CS=1; 
02F0:  BSF    F83.3
....................    TFT_CS = 0; 
02F2:  BCF    F83.0
....................    TFT_DC = 1;  //When DCX = ?? data is selected. 
02F4:  BSF    F83.2
....................    while(WriteSPI(parameter)); 
02F6:  MOVFF  CB,CC
02FA:  RCALL  02BA
02FC:  MOVF   01,F
02FE:  BNZ   02F6
....................    TFT_CS = 1; 
0300:  BSF    F83.0
.................... } 
0302:  RETURN 0
....................  
.................... //============================================================================== 
.................... // Fills screen with given color.  
.................... // color: color parameter. 
.................... //============================================================================== 
.................... void TFT_FillScreen(Unsigned long color) 
.................... { 
....................    Unsigned char DH, DL; 
....................    Unsigned int16 i, j; 
....................    DH = color >> 8; 
*
0574:  MOVFF  67,68
....................    DL = color & 0xFF; 
0578:  MOVFF  66,69
057C:  CLRF   19
057E:  BTFSC  FF2.7
0580:  BSF    19.7
0582:  BCF    FF2.7
....................    TFT_ColumnPage(0, TFT_W - 1, 0, TFT_H - 1); 
0584:  CLRF   xC2
0586:  CLRF   xC1
0588:  CLRF   xC4
058A:  MOVLW  EF
058C:  MOVWF  xC3
058E:  CLRF   xC6
0590:  CLRF   xC5
0592:  MOVLW  01
0594:  MOVWF  xC8
0596:  MOVLW  3F
0598:  MOVWF  xC7
059A:  RCALL  0304
059C:  BTFSC  19.7
059E:  BSF    FF2.7
....................    for(i = 0; i < TFT_W; i++) 
05A0:  CLRF   6B
05A2:  CLRF   6A
05A4:  MOVF   6B,F
05A6:  BNZ   05F4
05A8:  MOVF   6A,W
05AA:  SUBLW  EF
05AC:  BNC   05F4
....................    { 
....................       for (j = 0; j < TFT_H; j++) 
05AE:  CLRF   6D
05B0:  CLRF   6C
05B2:  MOVF   6D,W
05B4:  SUBLW  01
05B6:  BNC   05EC
05B8:  BNZ   05C0
05BA:  MOVF   6C,W
05BC:  SUBLW  3F
05BE:  BNC   05EC
05C0:  CLRF   19
05C2:  BTFSC  FF2.7
05C4:  BSF    19.7
05C6:  BCF    FF2.7
....................       { 
....................          TFT_WriteParameter(DH); 
05C8:  MOVFF  68,CB
05CC:  RCALL  02F0
05CE:  BTFSC  19.7
05D0:  BSF    FF2.7
05D2:  CLRF   19
05D4:  BTFSC  FF2.7
05D6:  BSF    19.7
05D8:  BCF    FF2.7
....................          TFT_WriteParameter(DL); 
05DA:  MOVFF  69,CB
05DE:  RCALL  02F0
05E0:  BTFSC  19.7
05E2:  BSF    FF2.7
....................       } 
05E4:  INCF   6C,F
05E6:  BTFSC  FD8.2
05E8:  INCF   6D,F
05EA:  BRA    05B2
....................    } 
05EC:  INCF   6A,F
05EE:  BTFSC  FD8.2
05F0:  INCF   6B,F
05F2:  BRA    05A4
.................... } 
05F4:  RETURN 0
....................  
....................  
....................  
.................... //============================================================================== 
.................... // Define area of frame memory where MCU can access. 
.................... // x: Set column address.  
.................... // y: Set Page address. 
.................... //============================================================================== 
.................... void TFT_ColumnRow(Unsigned int16 x, Unsigned int16 y) 
.................... { 
*
0C04:  CLRF   19
0C06:  BTFSC  FF2.7
0C08:  BSF    19.7
0C0A:  BCF    FF2.7
....................    TFT_WriteCommand(0x2A); 
0C0C:  MOVLW  2A
0C0E:  MOVWF  xC9
0C10:  CALL   02DC
0C14:  BTFSC  19.7
0C16:  BSF    FF2.7
....................    TFT_WriteParameter(x >> 8); 
0C18:  MOVFF  A5,A8
0C1C:  CLRF   xA9
0C1E:  CLRF   19
0C20:  BTFSC  FF2.7
0C22:  BSF    19.7
0C24:  BCF    FF2.7
0C26:  MOVFF  A5,CB
0C2A:  CALL   02F0
0C2E:  BTFSC  19.7
0C30:  BSF    FF2.7
....................    TFT_WriteParameter(x & 0xFF); 
0C32:  MOVFF  A4,A8
0C36:  CLRF   xA9
0C38:  CLRF   19
0C3A:  BTFSC  FF2.7
0C3C:  BSF    19.7
0C3E:  BCF    FF2.7
0C40:  MOVFF  A4,CB
0C44:  CALL   02F0
0C48:  BTFSC  19.7
0C4A:  BSF    FF2.7
....................    TFT_WriteParameter(x >> 8); 
0C4C:  MOVFF  A5,A8
0C50:  CLRF   xA9
0C52:  CLRF   19
0C54:  BTFSC  FF2.7
0C56:  BSF    19.7
0C58:  BCF    FF2.7
0C5A:  MOVFF  A5,CB
0C5E:  CALL   02F0
0C62:  BTFSC  19.7
0C64:  BSF    FF2.7
....................    TFT_WriteParameter(x & 0xFF); 
0C66:  MOVFF  A4,A8
0C6A:  CLRF   xA9
0C6C:  CLRF   19
0C6E:  BTFSC  FF2.7
0C70:  BSF    19.7
0C72:  BCF    FF2.7
0C74:  MOVFF  A4,CB
0C78:  CALL   02F0
0C7C:  BTFSC  19.7
0C7E:  BSF    FF2.7
0C80:  CLRF   19
0C82:  BTFSC  FF2.7
0C84:  BSF    19.7
0C86:  BCF    FF2.7
....................    TFT_WriteCommand(0x2B); 
0C88:  MOVLW  2B
0C8A:  MOVWF  xC9
0C8C:  CALL   02DC
0C90:  BTFSC  19.7
0C92:  BSF    FF2.7
....................    TFT_WriteParameter(y >> 8); 
0C94:  MOVFF  A7,A8
0C98:  CLRF   xA9
0C9A:  CLRF   19
0C9C:  BTFSC  FF2.7
0C9E:  BSF    19.7
0CA0:  BCF    FF2.7
0CA2:  MOVFF  A7,CB
0CA6:  CALL   02F0
0CAA:  BTFSC  19.7
0CAC:  BSF    FF2.7
....................    TFT_WriteParameter(y & 0xFF); 
0CAE:  MOVFF  A6,A8
0CB2:  CLRF   xA9
0CB4:  CLRF   19
0CB6:  BTFSC  FF2.7
0CB8:  BSF    19.7
0CBA:  BCF    FF2.7
0CBC:  MOVFF  A6,CB
0CC0:  CALL   02F0
0CC4:  BTFSC  19.7
0CC6:  BSF    FF2.7
....................    TFT_WriteParameter(y >> 8); 
0CC8:  MOVFF  A7,A8
0CCC:  CLRF   xA9
0CCE:  CLRF   19
0CD0:  BTFSC  FF2.7
0CD2:  BSF    19.7
0CD4:  BCF    FF2.7
0CD6:  MOVFF  A7,CB
0CDA:  CALL   02F0
0CDE:  BTFSC  19.7
0CE0:  BSF    FF2.7
....................    TFT_WriteParameter(y & 0xFF); 
0CE2:  MOVFF  A6,A8
0CE6:  CLRF   xA9
0CE8:  CLRF   19
0CEA:  BTFSC  FF2.7
0CEC:  BSF    19.7
0CEE:  BCF    FF2.7
0CF0:  MOVFF  A6,CB
0CF4:  CALL   02F0
0CF8:  BTFSC  19.7
0CFA:  BSF    FF2.7
0CFC:  CLRF   19
0CFE:  BTFSC  FF2.7
0D00:  BSF    19.7
0D02:  BCF    FF2.7
....................     
....................    TFT_WriteCommand(0x2C);       // Enable Memory Write 
0D04:  MOVLW  2C
0D06:  MOVWF  xC9
0D08:  CALL   02DC
0D0C:  BTFSC  19.7
0D0E:  BSF    FF2.7
.................... } 
0D10:  GOTO   0D26 (RETURN)
....................  
....................  
.................... //============================================================================== 
.................... // Define area of frame memory where MCU can access. 
.................... // x1: Set start column address.  
.................... // x2: Set end column address.  
.................... // y1: Set start page address. 
.................... // y2: Set end page address. 
.................... //============================================================================== 
.................... void TFT_ColumnPage(Unsigned int16 x1, Unsigned int16 x2, Unsigned int16 y1, Unsigned int16 y2) 
.................... { 
....................    TFT_WriteCommand(0x2A); 
*
0304:  MOVLW  2A
0306:  MOVWF  xC9
0308:  RCALL  02DC
....................    TFT_WriteParameter(x1 >> 8); 
030A:  MOVFF  C2,C9
030E:  CLRF   xCA
0310:  MOVFF  C2,CB
0314:  RCALL  02F0
....................    TFT_WriteParameter(x1 & 0xFF); 
0316:  MOVFF  C1,C9
031A:  CLRF   xCA
031C:  MOVFF  C1,CB
0320:  RCALL  02F0
....................    TFT_WriteParameter(x2 >> 8); 
0322:  MOVFF  C4,C9
0326:  CLRF   xCA
0328:  MOVFF  C4,CB
032C:  RCALL  02F0
....................    TFT_WriteParameter(x2 & 0xFF); 
032E:  MOVFF  C3,C9
0332:  CLRF   xCA
0334:  MOVFF  C3,CB
0338:  RCALL  02F0
....................    TFT_WriteCommand(0x2B); 
033A:  MOVLW  2B
033C:  MOVWF  xC9
033E:  RCALL  02DC
....................    TFT_WriteParameter(y1 >> 8); 
0340:  MOVFF  C6,C9
0344:  CLRF   xCA
0346:  MOVFF  C6,CB
034A:  RCALL  02F0
....................    TFT_WriteParameter(y1 & 0xFF); 
034C:  MOVFF  C5,C9
0350:  CLRF   xCA
0352:  MOVFF  C5,CB
0356:  RCALL  02F0
....................    TFT_WriteParameter(y2 >> 8); 
0358:  MOVFF  C8,C9
035C:  CLRF   xCA
035E:  MOVFF  C8,CB
0362:  RCALL  02F0
....................    TFT_WriteParameter(y2 & 0xFF); 
0364:  MOVFF  C7,C9
0368:  CLRF   xCA
036A:  MOVFF  C7,CB
036E:  RCALL  02F0
....................     
....................    TFT_WriteCommand(0x2C);       // Enable Memory Write 
0370:  MOVLW  2C
0372:  MOVWF  xC9
0374:  RCALL  02DC
.................... } 
0376:  RETURN 0
....................  
.................... //============================================================================== 
.................... // RGBConvert(red, green, blue). 
.................... // 16 bit/pixel color order (R:5-bit, G:6-bit, B:5-bit), 65,536 colors. 
.................... // 8-8-8 to to 5-6-5 conversion. 
.................... //============================================================================== 
.................... unsigned int16 TFT_RGBConvert(Unsigned int16 red8, Unsigned int16 green8, Unsigned int16 blue8) 
.................... { 
....................    Unsigned int16 color = 0; 
....................    red8 = (red8 & 0x1F) << 11;  
....................    green8 = (green8 & 0x3F) << 5;  
....................    blue8 = blue8 & 0x1F; 
....................    color = red8 | green8 | blue8; 
....................    return color; 
.................... } 
....................  
.................... //============================================================================== 
.................... // Draws a Pixel on TFT. 
.................... // x: x position. Valid values: 0..240  
.................... // y: y position. Valid values: 0..320  
.................... // color: color parameter. 
.................... //============================================================================== 
.................... void TFT_Pixel(Unsigned int16 x, Unsigned int16 y, Unsigned int16 color) 
.................... { 
....................    TFT_ColumnRow(x, y); 
*
0D14:  MOVFF  9F,A5
0D18:  MOVFF  9E,A4
0D1C:  MOVFF  A1,A7
0D20:  MOVFF  A0,A6
0D24:  BRA    0C04
....................    TFT_WriteParameter(color >> 8); 
0D26:  MOVFF  A3,A4
0D2A:  CLRF   xA5
0D2C:  CLRF   19
0D2E:  BTFSC  FF2.7
0D30:  BSF    19.7
0D32:  BCF    FF2.7
0D34:  MOVFF  A3,CB
0D38:  CALL   02F0
0D3C:  BTFSC  19.7
0D3E:  BSF    FF2.7
....................    TFT_WriteParameter(color & 0xFF); 
0D40:  MOVFF  A2,A4
0D44:  CLRF   xA5
0D46:  CLRF   19
0D48:  BTFSC  FF2.7
0D4A:  BSF    19.7
0D4C:  BCF    FF2.7
0D4E:  MOVFF  A2,CB
0D52:  CALL   02F0
0D56:  BTFSC  19.7
0D58:  BSF    FF2.7
.................... } 
0D5A:  RETURN 0
....................  
....................  
.................... //============================================================================== 
.................... // Draws a box on TFT. 
.................... // x1: x coordinate of the upper left rectangle corner. Valid values: 0..240   
.................... // y1: y coordinate of the upper left rectangle corner. Valid values: 0..320  
.................... // x2: x coordinate of the lower right rectangle corner. Valid values: 0..240  
.................... // y2: y coordinate of the lower right rectangle corner. Valid values: 0..320  
.................... // color: color parameter.  
.................... //============================================================================== 
.................... void TFT_Box(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color) 
.................... { 
.................... /*   while(y1<=y2) 
....................    { 
....................       TFT_Line(x1, y1, x2, y1, color); 
....................       y1++; 
....................    }*/ 
....................    Unsigned char DH, DL; 
....................    Unsigned int16 i, j; 
....................    Unsigned int16 Box_W,Box_H; 
....................    Box_W = x2; 
*
0378:  MOVFF  B2,BE
037C:  MOVFF  B1,BD
....................    Box_H = y2;  
0380:  MOVFF  B4,C0
0384:  MOVFF  B3,BF
....................    DH = color >> 8; 
0388:  MOVFF  B6,B7
....................    DL = color & 0xFF; 
038C:  MOVFF  B5,B8
....................    TFT_ColumnPage(x1, x2, y1, y2); 
0390:  MOVFF  AE,C2
0394:  MOVFF  AD,C1
0398:  MOVFF  B2,C4
039C:  MOVFF  B1,C3
03A0:  MOVFF  B0,C6
03A4:  MOVFF  AF,C5
03A8:  MOVFF  B4,C8
03AC:  MOVFF  B3,C7
03B0:  RCALL  0304
....................    for(i = 0; i < Box_W; i++) 
03B2:  CLRF   xBA
03B4:  CLRF   xB9
03B6:  MOVF   xBA,W
03B8:  SUBWF  xBE,W
03BA:  BNC   03F2
03BC:  BNZ   03C4
03BE:  MOVF   xBD,W
03C0:  SUBWF  xB9,W
03C2:  BC    03F2
....................    { 
....................     for (j = 0; j < Box_H; j++) 
03C4:  CLRF   xBC
03C6:  CLRF   xBB
03C8:  MOVF   xBC,W
03CA:  SUBWF  xC0,W
03CC:  BNC   03EA
03CE:  BNZ   03D6
03D0:  MOVF   xBF,W
03D2:  SUBWF  xBB,W
03D4:  BC    03EA
....................         { 
....................             TFT_WriteParameter(DH); 
03D6:  MOVFF  B7,CB
03DA:  RCALL  02F0
....................             TFT_WriteParameter(DL);  
03DC:  MOVFF  B8,CB
03E0:  RCALL  02F0
....................         } 
03E2:  INCF   xBB,F
03E4:  BTFSC  FD8.2
03E6:  INCF   xBC,F
03E8:  BRA    03C8
....................    } 
03EA:  INCF   xB9,F
03EC:  BTFSC  FD8.2
03EE:  INCF   xBA,F
03F0:  BRA    03B6
.................... } 
03F2:  RETURN 0
....................  
....................  
.................... //============================================================================== 
.................... // Drawing a Line on TFT. 
.................... // 
.................... // Bresenham algorithm. 
.................... //  
.................... // x1: x coordinate of the line start. Valid values: 0..240 
.................... // y1: y coordinate of the line start. Valid values: 0..320  
.................... // x2: x coordinate of the line end. Valid values: 0..240  
.................... // y2: y coordinate of the line end. Valid values: 0..320  
.................... // color: color parameter. 
.................... //============================================================================== 
.................... void TFT_Line(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color) 
.................... { 
*
0D5C:  MOVF   x80,W
0D5E:  SUBWF  x84,W
0D60:  MOVWF  x92
0D62:  MOVF   x81,W
0D64:  SUBWFB x85,W
0D66:  MOVWF  x93
0D68:  MOVF   x82,W
0D6A:  SUBWF  x86,W
0D6C:  MOVWF  x94
0D6E:  MOVF   x83,W
0D70:  SUBWFB x87,W
0D72:  MOVWF  x95
0D74:  CLRF   x97
0D76:  CLRF   x96
0D78:  CLRF   x99
0D7A:  CLRF   x98
0D7C:  CLRF   x9B
0D7E:  CLRF   x9A
0D80:  CLRF   x9D
0D82:  CLRF   x9C
....................    int16 i; 
....................    int16 longest, shortest;  
....................    int16 numerator; 
....................    int16 w = x2 - x1; 
....................    int16 h = y2 - y1; 
....................    int16 dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0; 
....................     
....................    if(w < 0) dx1 = -1; else if(w > 0) dx1 = 1; 
0D84:  MOVF   x92,F
0D86:  BNZ   0D8C
0D88:  MOVF   x93,F
0D8A:  BZ    0D92
0D8C:  CLRF   x97
0D8E:  MOVLW  01
0D90:  MOVWF  x96
....................    if(h < 0) dy1 = -1; else if(h > 0) dy1 = 1; 
0D92:  MOVF   x94,F
0D94:  BNZ   0D9A
0D96:  MOVF   x95,F
0D98:  BZ    0DA0
0D9A:  CLRF   x99
0D9C:  MOVLW  01
0D9E:  MOVWF  x98
....................    if(w < 0) dx2 = -1; else if(w > 0) dx2 = 1; 
0DA0:  MOVF   x92,F
0DA2:  BNZ   0DA8
0DA4:  MOVF   x93,F
0DA6:  BZ    0DAE
0DA8:  CLRF   x9B
0DAA:  MOVLW  01
0DAC:  MOVWF  x9A
....................    if(w < 0) w *= -1; 
....................    if(h < 0) h *= -1; 
....................    longest = w;  
0DAE:  MOVFF  93,8D
0DB2:  MOVFF  92,8C
....................    shortest = h; 
0DB6:  MOVFF  95,8F
0DBA:  MOVFF  94,8E
....................    if(!(longest > shortest))  
0DBE:  MOVF   x8F,W
0DC0:  SUBWF  x8D,W
0DC2:  BNC   0DCC
0DC4:  BNZ   0DEE
0DC6:  MOVF   x8C,W
0DC8:  SUBWF  x8E,W
0DCA:  BNC   0DEE
....................    {//if(w < 0) w *= -1; //if(h < 0) h *= -1;  
....................       longest = h;  
0DCC:  MOVFF  95,8D
0DD0:  MOVFF  94,8C
....................       shortest = w; 
0DD4:  MOVFF  93,8F
0DD8:  MOVFF  92,8E
....................       if(h < 0) dy2 = -1; else if(h > 0) dy2 = 1; 
0DDC:  MOVF   x94,F
0DDE:  BNZ   0DE4
0DE0:  MOVF   x95,F
0DE2:  BZ    0DEA
0DE4:  CLRF   x9D
0DE6:  MOVLW  01
0DE8:  MOVWF  x9C
....................       dx2 = 0;          
0DEA:  CLRF   x9B
0DEC:  CLRF   x9A
....................    } 
....................    numerator = longest >> 1; 
0DEE:  BCF    FD8.0
0DF0:  RRCF   x8D,W
0DF2:  MOVWF  x91
0DF4:  RRCF   x8C,W
0DF6:  MOVWF  x90
....................    for (i = 0; i <= longest; i++) 
0DF8:  CLRF   x8B
0DFA:  CLRF   x8A
0DFC:  MOVF   x8B,W
0DFE:  SUBWF  x8D,W
0E00:  BNC   0E6C
0E02:  BNZ   0E0A
0E04:  MOVF   x8A,W
0E06:  SUBWF  x8C,W
0E08:  BNC   0E6C
....................    { 
....................       TFT_Pixel(x1, y1, color); 
0E0A:  MOVFF  81,9F
0E0E:  MOVFF  80,9E
0E12:  MOVFF  83,A1
0E16:  MOVFF  82,A0
0E1A:  MOVFF  89,A3
0E1E:  MOVFF  88,A2
0E22:  RCALL  0D14
....................       numerator += shortest; 
0E24:  MOVF   x8E,W
0E26:  ADDWF  x90,F
0E28:  MOVF   x8F,W
0E2A:  ADDWFC x91,F
....................       if(!(numerator < longest))  
0E2C:  MOVF   x91,W
0E2E:  SUBWF  x8D,W
0E30:  BNC   0E3A
0E32:  BNZ   0E54
0E34:  MOVF   x8C,W
0E36:  SUBWF  x90,W
0E38:  BNC   0E54
....................       { 
....................          numerator -= longest; 
0E3A:  MOVF   x8C,W
0E3C:  SUBWF  x90,F
0E3E:  MOVF   x8D,W
0E40:  SUBWFB x91,F
....................          x1 += dx1; 
0E42:  MOVF   x96,W
0E44:  ADDWF  x80,F
0E46:  MOVF   x97,W
0E48:  ADDWFC x81,F
....................          y1 += dy1; 
0E4A:  MOVF   x98,W
0E4C:  ADDWF  x82,F
0E4E:  MOVF   x99,W
0E50:  ADDWFC x83,F
....................       }else 
0E52:  BRA    0E64
....................       { 
....................          x1 += dx2; 
0E54:  MOVF   x9A,W
0E56:  ADDWF  x80,F
0E58:  MOVF   x9B,W
0E5A:  ADDWFC x81,F
....................          y1 += dy2; 
0E5C:  MOVF   x9C,W
0E5E:  ADDWF  x82,F
0E60:  MOVF   x9D,W
0E62:  ADDWFC x83,F
....................       } 
....................    } 
0E64:  INCF   x8A,F
0E66:  BTFSC  FD8.2
0E68:  INCF   x8B,F
0E6A:  BRA    0DFC
.................... } 
0E6C:  RETURN 0
....................  
.................... //============================================================================== 
.................... // Draws a rectangle on TFT. 
.................... // x1: x coordinate of the upper left rectangle corner. Valid values: 0..240   
.................... // y1: y coordinate of the upper left rectangle corner. Valid values: 0..320  
.................... // x2: x coordinate of the lower right rectangle corner. Valid values: 0..240  
.................... // y2: y coordinate of the lower right rectangle corner. Valid values: 0..320  
.................... // color: color parameter. 
.................... //============================================================================== 
.................... void TFT_Rectangle(Unsigned int16 x1, Unsigned int16 y1, Unsigned int16 x2, Unsigned int16 y2, Unsigned int16 color) 
.................... { 
....................    TFT_Line(x1, y1, x2, y1, color); 
....................    TFT_Line(x1, y2, x2, y2, color); 
....................    TFT_Line(x1, y1, x1, y2, color); 
....................    TFT_Line(x2, y1, x2, y2, color); 
.................... } 
....................  
.................... //============================================================================== 
.................... // Draws a circle on TFT. 
.................... // 
.................... // Midpoint circle algorithm. 
.................... // 
.................... // SX: x coordinate of the circle center. Valid values: 0..240 
.................... // SY: y coordinate of the circle center. Valid values: 0..320 
.................... // radius: radius size 
.................... // color: color parameter. 
.................... //============================================================================== 
.................... void TFT_Circle(unsigned int16 SX, unsigned int16 SY, unsigned int16 Radius,unsigned int16 Fill, unsigned int16 Color) 
.................... { 
....................  
....................    unsigned int16 x,y; 
....................    int16 delta,tmp; 
....................    x = 0; 
*
1E2C:  CLRF   71
1E2E:  CLRF   70
....................    y = Radius; 
1E30:  MOVFF  6B,73
1E34:  MOVFF  6A,72
....................    delta = 3 - (Radius << 1); 
1E38:  BCF    FD8.0
1E3A:  RLCF   6A,W
1E3C:  MOVWF  02
1E3E:  RLCF   6B,W
1E40:  MOVWF  03
1E42:  MOVF   02,W
1E44:  XORLW  FF
1E46:  ADDLW  04
1E48:  MOVWF  74
1E4A:  MOVLW  00
1E4C:  SUBFWB 03,W
1E4E:  MOVWF  75
....................  
....................    while(y >= x) 
....................    { 
1E50:  MOVF   71,W
1E52:  SUBWF  73,W
1E54:  BTFSS  FD8.0
1E56:  BRA    2228
1E58:  BNZ   1E62
1E5A:  MOVF   70,W
1E5C:  SUBWF  72,W
1E5E:  BTFSS  FD8.0
1E60:  BRA    2228
....................       if(Fill) 
1E62:  MOVF   6C,W
1E64:  IORWF  6D,W
1E66:  BTFSC  FD8.2
1E68:  BRA    1FD4
....................       { 
....................          TFT_Line(SX-x, SY+y, SX+x, SY+y, color); 
1E6A:  MOVF   70,W
1E6C:  SUBWF  66,W
1E6E:  MOVWF  78
1E70:  MOVF   71,W
1E72:  SUBWFB 67,W
1E74:  MOVWF  79
1E76:  MOVF   72,W
1E78:  ADDWF  68,W
1E7A:  MOVWF  7A
1E7C:  MOVF   73,W
1E7E:  ADDWFC 69,W
1E80:  MOVWF  7B
1E82:  MOVF   70,W
1E84:  ADDWF  66,W
1E86:  MOVWF  7C
1E88:  MOVF   71,W
1E8A:  ADDWFC 67,W
1E8C:  MOVWF  7D
1E8E:  MOVF   72,W
1E90:  ADDWF  68,W
1E92:  MOVWF  7E
1E94:  MOVF   73,W
1E96:  ADDWFC 69,W
1E98:  MOVWF  7F
1E9A:  MOVFF  79,81
1E9E:  MOVFF  78,80
1EA2:  MOVFF  7B,83
1EA6:  MOVFF  7A,82
1EAA:  MOVFF  7D,85
1EAE:  MOVFF  7C,84
1EB2:  MOVWF  x87
1EB4:  MOVFF  7E,86
1EB8:  MOVFF  6F,89
1EBC:  MOVFF  6E,88
1EC0:  CALL   0D5C
....................          TFT_Line(SX-x, SY-y, SX+x, SY-y, color); 
1EC4:  MOVF   70,W
1EC6:  SUBWF  66,W
1EC8:  MOVWF  78
1ECA:  MOVF   71,W
1ECC:  SUBWFB 67,W
1ECE:  MOVWF  79
1ED0:  MOVF   72,W
1ED2:  SUBWF  68,W
1ED4:  MOVWF  7A
1ED6:  MOVF   73,W
1ED8:  SUBWFB 69,W
1EDA:  MOVWF  7B
1EDC:  MOVF   70,W
1EDE:  ADDWF  66,W
1EE0:  MOVWF  7C
1EE2:  MOVF   71,W
1EE4:  ADDWFC 67,W
1EE6:  MOVWF  7D
1EE8:  MOVF   72,W
1EEA:  SUBWF  68,W
1EEC:  MOVWF  7E
1EEE:  MOVF   73,W
1EF0:  SUBWFB 69,W
1EF2:  MOVWF  7F
1EF4:  MOVFF  79,81
1EF8:  MOVFF  78,80
1EFC:  MOVFF  7B,83
1F00:  MOVFF  7A,82
1F04:  MOVFF  7D,85
1F08:  MOVFF  7C,84
1F0C:  MOVWF  x87
1F0E:  MOVFF  7E,86
1F12:  MOVFF  6F,89
1F16:  MOVFF  6E,88
1F1A:  CALL   0D5C
....................          TFT_Line(SX-y, SY+x, SX+y, SY+x, color); 
1F1E:  MOVF   72,W
1F20:  SUBWF  66,W
1F22:  MOVWF  78
1F24:  MOVF   73,W
1F26:  SUBWFB 67,W
1F28:  MOVWF  79
1F2A:  MOVF   70,W
1F2C:  ADDWF  68,W
1F2E:  MOVWF  7A
1F30:  MOVF   71,W
1F32:  ADDWFC 69,W
1F34:  MOVWF  7B
1F36:  MOVF   72,W
1F38:  ADDWF  66,W
1F3A:  MOVWF  7C
1F3C:  MOVF   73,W
1F3E:  ADDWFC 67,W
1F40:  MOVWF  7D
1F42:  MOVF   70,W
1F44:  ADDWF  68,W
1F46:  MOVWF  7E
1F48:  MOVF   71,W
1F4A:  ADDWFC 69,W
1F4C:  MOVWF  7F
1F4E:  MOVFF  79,81
1F52:  MOVFF  78,80
1F56:  MOVFF  7B,83
1F5A:  MOVFF  7A,82
1F5E:  MOVFF  7D,85
1F62:  MOVFF  7C,84
1F66:  MOVWF  x87
1F68:  MOVFF  7E,86
1F6C:  MOVFF  6F,89
1F70:  MOVFF  6E,88
1F74:  CALL   0D5C
....................          TFT_Line(SX-y, SY-x, SX+y, SY-x, color); 
1F78:  MOVF   72,W
1F7A:  SUBWF  66,W
1F7C:  MOVWF  78
1F7E:  MOVF   73,W
1F80:  SUBWFB 67,W
1F82:  MOVWF  79
1F84:  MOVF   70,W
1F86:  SUBWF  68,W
1F88:  MOVWF  7A
1F8A:  MOVF   71,W
1F8C:  SUBWFB 69,W
1F8E:  MOVWF  7B
1F90:  MOVF   72,W
1F92:  ADDWF  66,W
1F94:  MOVWF  7C
1F96:  MOVF   73,W
1F98:  ADDWFC 67,W
1F9A:  MOVWF  7D
1F9C:  MOVF   70,W
1F9E:  SUBWF  68,W
1FA0:  MOVWF  7E
1FA2:  MOVF   71,W
1FA4:  SUBWFB 69,W
1FA6:  MOVWF  7F
1FA8:  MOVFF  79,81
1FAC:  MOVFF  78,80
1FB0:  MOVFF  7B,83
1FB4:  MOVFF  7A,82
1FB8:  MOVFF  7D,85
1FBC:  MOVFF  7C,84
1FC0:  MOVWF  x87
1FC2:  MOVFF  7E,86
1FC6:  MOVFF  6F,89
1FCA:  MOVFF  6E,88
1FCE:  CALL   0D5C
....................       } 
....................       else 
1FD2:  BRA    2164
....................       { 
....................          TFT_Pixel(SX + x, SY + y, Color); 
1FD4:  MOVF   70,W
1FD6:  ADDWF  66,W
1FD8:  MOVWF  78
1FDA:  MOVF   71,W
1FDC:  ADDWFC 67,W
1FDE:  MOVWF  79
1FE0:  MOVF   72,W
1FE2:  ADDWF  68,W
1FE4:  MOVWF  7A
1FE6:  MOVF   73,W
1FE8:  ADDWFC 69,W
1FEA:  MOVWF  7B
1FEC:  MOVFF  79,9F
1FF0:  MOVFF  78,9E
1FF4:  MOVWF  xA1
1FF6:  MOVFF  7A,A0
1FFA:  MOVFF  6F,A3
1FFE:  MOVFF  6E,A2
2002:  CALL   0D14
....................          TFT_Pixel(SX - x, SY + y, Color); 
2006:  MOVF   70,W
2008:  SUBWF  66,W
200A:  MOVWF  78
200C:  MOVF   71,W
200E:  SUBWFB 67,W
2010:  MOVWF  79
2012:  MOVF   72,W
2014:  ADDWF  68,W
2016:  MOVWF  7A
2018:  MOVF   73,W
201A:  ADDWFC 69,W
201C:  MOVWF  7B
201E:  MOVFF  79,9F
2022:  MOVFF  78,9E
2026:  MOVWF  xA1
2028:  MOVFF  7A,A0
202C:  MOVFF  6F,A3
2030:  MOVFF  6E,A2
2034:  CALL   0D14
....................          TFT_Pixel(SX + x, SY - y, Color); 
2038:  MOVF   70,W
203A:  ADDWF  66,W
203C:  MOVWF  78
203E:  MOVF   71,W
2040:  ADDWFC 67,W
2042:  MOVWF  79
2044:  MOVF   72,W
2046:  SUBWF  68,W
2048:  MOVWF  7A
204A:  MOVF   73,W
204C:  SUBWFB 69,W
204E:  MOVWF  7B
2050:  MOVFF  79,9F
2054:  MOVFF  78,9E
2058:  MOVWF  xA1
205A:  MOVFF  7A,A0
205E:  MOVFF  6F,A3
2062:  MOVFF  6E,A2
2066:  CALL   0D14
....................          TFT_Pixel(SX - x, SY - y, Color); 
206A:  MOVF   70,W
206C:  SUBWF  66,W
206E:  MOVWF  78
2070:  MOVF   71,W
2072:  SUBWFB 67,W
2074:  MOVWF  79
2076:  MOVF   72,W
2078:  SUBWF  68,W
207A:  MOVWF  7A
207C:  MOVF   73,W
207E:  SUBWFB 69,W
2080:  MOVWF  7B
2082:  MOVFF  79,9F
2086:  MOVFF  78,9E
208A:  MOVWF  xA1
208C:  MOVFF  7A,A0
2090:  MOVFF  6F,A3
2094:  MOVFF  6E,A2
2098:  CALL   0D14
....................          TFT_Pixel(SX + y, SY + x, Color); 
209C:  MOVF   72,W
209E:  ADDWF  66,W
20A0:  MOVWF  78
20A2:  MOVF   73,W
20A4:  ADDWFC 67,W
20A6:  MOVWF  79
20A8:  MOVF   70,W
20AA:  ADDWF  68,W
20AC:  MOVWF  7A
20AE:  MOVF   71,W
20B0:  ADDWFC 69,W
20B2:  MOVWF  7B
20B4:  MOVFF  79,9F
20B8:  MOVFF  78,9E
20BC:  MOVWF  xA1
20BE:  MOVFF  7A,A0
20C2:  MOVFF  6F,A3
20C6:  MOVFF  6E,A2
20CA:  CALL   0D14
....................          TFT_Pixel(SX - y, SY + x, Color); 
20CE:  MOVF   72,W
20D0:  SUBWF  66,W
20D2:  MOVWF  78
20D4:  MOVF   73,W
20D6:  SUBWFB 67,W
20D8:  MOVWF  79
20DA:  MOVF   70,W
20DC:  ADDWF  68,W
20DE:  MOVWF  7A
20E0:  MOVF   71,W
20E2:  ADDWFC 69,W
20E4:  MOVWF  7B
20E6:  MOVFF  79,9F
20EA:  MOVFF  78,9E
20EE:  MOVWF  xA1
20F0:  MOVFF  7A,A0
20F4:  MOVFF  6F,A3
20F8:  MOVFF  6E,A2
20FC:  CALL   0D14
....................          TFT_Pixel(SX + y, SY - x, Color); 
2100:  MOVF   72,W
2102:  ADDWF  66,W
2104:  MOVWF  78
2106:  MOVF   73,W
2108:  ADDWFC 67,W
210A:  MOVWF  79
210C:  MOVF   70,W
210E:  SUBWF  68,W
2110:  MOVWF  7A
2112:  MOVF   71,W
2114:  SUBWFB 69,W
2116:  MOVWF  7B
2118:  MOVFF  79,9F
211C:  MOVFF  78,9E
2120:  MOVWF  xA1
2122:  MOVFF  7A,A0
2126:  MOVFF  6F,A3
212A:  MOVFF  6E,A2
212E:  CALL   0D14
....................          TFT_Pixel(SX - y, SY - x, Color); 
2132:  MOVF   72,W
2134:  SUBWF  66,W
2136:  MOVWF  78
2138:  MOVF   73,W
213A:  SUBWFB 67,W
213C:  MOVWF  79
213E:  MOVF   70,W
2140:  SUBWF  68,W
2142:  MOVWF  7A
2144:  MOVF   71,W
2146:  SUBWFB 69,W
2148:  MOVWF  7B
214A:  MOVFF  79,9F
214E:  MOVFF  78,9E
2152:  MOVWF  xA1
2154:  MOVFF  7A,A0
2158:  MOVFF  6F,A3
215C:  MOVFF  6E,A2
2160:  CALL   0D14
....................       } 
....................       x++; 
2164:  INCF   70,F
2166:  BTFSC  FD8.2
2168:  INCF   71,F
....................       if(delta >= 0) 
....................       { 
....................          y=sqrt(Radius*Radius - x*x); 
216A:  MOVFF  6B,7B
216E:  MOVFF  6A,7A
2172:  MOVFF  6B,7D
2176:  MOVFF  6A,7C
217A:  RCALL  1CFA
217C:  MOVFF  02,79
2180:  MOVFF  01,78
2184:  MOVFF  71,7B
2188:  MOVFF  70,7A
218C:  MOVFF  71,7D
2190:  MOVFF  70,7C
2194:  RCALL  1CFA
2196:  MOVF   01,W
2198:  SUBWF  78,W
219A:  MOVWF  00
219C:  MOVF   02,W
219E:  SUBWFB 79,W
21A0:  MOVWF  03
21A2:  MOVFF  00,7A
21A6:  MOVWF  7B
21A8:  CALL   0FDE
21AC:  MOVFF  00,78
21B0:  MOVFF  01,79
21B4:  MOVFF  02,7A
21B8:  MOVFF  03,7B
21BC:  MOVFF  03,7F
21C0:  MOVFF  02,7E
21C4:  MOVFF  01,7D
21C8:  MOVFF  00,7C
21CC:  BRA    1D18
21CE:  MOVFF  03,7B
21D2:  MOVFF  02,7A
21D6:  MOVFF  01,79
21DA:  MOVFF  00,78
21DE:  CALL   12F4
21E2:  MOVFF  02,73
21E6:  MOVFF  01,72
....................          tmp = (x << 2); 
21EA:  RLCF   70,W
21EC:  MOVWF  76
21EE:  RLCF   71,W
21F0:  MOVWF  77
21F2:  RLCF   76,F
21F4:  RLCF   77,F
21F6:  MOVLW  FC
21F8:  ANDWF  76,F
....................          tmp -= (y << 2); 
21FA:  RLCF   72,W
21FC:  MOVWF  02
21FE:  RLCF   73,W
2200:  MOVWF  03
2202:  RLCF   02,F
2204:  RLCF   03,F
2206:  MOVLW  FC
2208:  ANDWF  02,F
220A:  MOVF   02,W
220C:  SUBWF  76,F
220E:  MOVF   03,W
2210:  SUBWFB 77,F
....................          delta += (tmp + 10); 
2212:  MOVLW  0A
2214:  ADDWF  76,W
2216:  MOVWF  01
2218:  MOVLW  00
221A:  ADDWFC 77,W
221C:  MOVWF  03
221E:  MOVF   01,W
2220:  ADDWF  74,F
2222:  MOVF   03,W
2224:  ADDWFC 75,F
....................       } 
....................       else 
....................       { 
....................          delta += ((x << 2) + 6); 
....................       } 
....................    } 
2226:  BRA    1E50
.................... } 
2228:  GOTO   23F6 (RETURN)
....................  
....................  
.................... //============================================================================== 
.................... // Drawing to TEST 
.................... //============================================================================== 
.................... void test_drawing(void) 
.................... { 
....................    TFT_FillScreen(RED); 
....................    TFT_FillScreen(GREEN); 
....................    TFT_FillScreen(YELLOW); 
....................    delay_ms(2000); 
....................    TFT_Box(2, 10, 50, 30, BLACK);  
....................    delay_ms(500); 
....................    TFT_Line(100, 100, 200, 200, RED);  
....................    delay_ms(500); 
....................    TFT_Circle(100, 100, 50,0, BLUE); 
....................    delay_ms(500); 
....................    TFT_Circle(150, 200, 30,1, GREEN); 
....................    delay_ms(500); 
....................    TFT_Rectangle(2, 250, 150, 300, BROWN); 
....................    delay_ms(1000); 
.................... } 
....................  
.................... //============================================================================== 
.................... // Touch Pad init 
.................... //============================================================================== 
.................... void touch_init(void) 
.................... { 
....................    TRIS_Yp = 0; 
*
0514:  BCF    F95.7
....................    TRIS_Xp = 0; 
0516:  BCF    F95.6
....................    TRIS_Ym = 0; 
0518:  BCF    F95.5
....................    TRIS_Xm = 0; 
051A:  BCF    F95.4
....................    TRIS_TS_CS = 0; 
051C:  BCF    F95.3
....................    TS_CS=1; 
051E:  BSF    F83.3
.................... } 
0520:  GOTO   2296 (RETURN)
.................... //============================================================================== 
.................... // Read MCP ch0 (X val) 
.................... //============================================================================== 
.................... int16 Read_X(void) 
.................... { 
....................    int16 temp; 
....................    TRIS_Xp=0; TRIS_Xm=0; 
*
0F98:  BCF    F95.6
0F9A:  BCF    F95.4
....................    Xp=1;      Xm=0; 
0F9C:  BSF    F83.6
0F9E:  BCF    F83.4
....................     
....................    TFT_CS=1; 
0FA0:  BSF    F83.0
....................    TS_CS = 0; 
0FA2:  BCF    F83.3
....................     
....................    SSPBUF = 0x01; 
0FA4:  MOVLW  01
0FA6:  MOVWF  FC9
....................    while(!SSPIF); 
0FA8:  BTFSS  F9E.3
0FAA:  BRA    0FA8
....................    SSPIF = 0; 
0FAC:  BCF    F9E.3
....................     
....................    SSPBUF = 0x80; 
0FAE:  MOVLW  80
0FB0:  MOVWF  FC9
....................    while(!SSPIF); 
0FB2:  BTFSS  F9E.3
0FB4:  BRA    0FB2
....................    SSPIF = 0; 
0FB6:  BCF    F9E.3
....................    temp = (int16)(SSPBUF&0x0f)<<8; 
0FB8:  MOVF   FC9,W
0FBA:  ANDLW  0F
0FBC:  MOVWF  71
0FBE:  CLRF   70
....................  
....................    SSPBUF = 0x00; 
0FC0:  CLRF   FC9
....................    while(!SSPIF); 
0FC2:  BTFSS  F9E.3
0FC4:  BRA    0FC2
....................    SSPIF = 0; 
0FC6:  BCF    F9E.3
....................    temp = temp|(SSPBUF&0xFF); 
0FC8:  MOVF   FC9,W
0FCA:  IORWF  70,F
....................     
....................    TS_CS = 1; 
0FCC:  BSF    F83.3
....................     
....................    TRIS_Xp=1; TRIS_Xm=1; 
0FCE:  BSF    F95.6
0FD0:  BSF    F95.4
....................    return temp; 
0FD2:  MOVFF  70,01
0FD6:  MOVFF  71,02
.................... } 
0FDA:  GOTO   172E (RETURN)
....................  
.................... //============================================================================== 
.................... // Read MCP ch1(Y val) 
.................... //============================================================================== 
.................... int16 Read_Y(void) 
.................... { 
....................    int16 temp; 
....................     
....................    TRIS_Yp=0; TRIS_Ym=0; 
*
194A:  BCF    F95.7
194C:  BCF    F95.5
....................    Yp=1;      Ym=0; 
194E:  BSF    F83.7
1950:  BCF    F83.5
....................  
....................    TFT_CS=1; 
1952:  BSF    F83.0
....................    TS_CS = 0; 
1954:  BCF    F83.3
....................    SSPBUF = 0x01; 
1956:  MOVLW  01
1958:  MOVWF  FC9
....................    while(!SSPIF); 
195A:  BTFSS  F9E.3
195C:  BRA    195A
....................    SSPIF = 0; 
195E:  BCF    F9E.3
....................    SSPBUF = 0xC0; 
1960:  MOVLW  C0
1962:  MOVWF  FC9
....................    while(!SSPIF); 
1964:  BTFSS  F9E.3
1966:  BRA    1964
....................    SSPIF = 0; 
1968:  BCF    F9E.3
....................    temp = (int16)(SSPBUF&0x0f)<<8; 
196A:  MOVF   FC9,W
196C:  ANDLW  0F
196E:  MOVWF  71
1970:  CLRF   70
....................  
....................    SSPBUF = 0x00; 
1972:  CLRF   FC9
....................    while(!SSPIF); 
1974:  BTFSS  F9E.3
1976:  BRA    1974
....................    SSPIF = 0; 
1978:  BCF    F9E.3
....................    temp = temp|(SSPBUF&0xFF); 
197A:  MOVF   FC9,W
197C:  IORWF  70,F
....................     
....................    TS_CS = 1; 
197E:  BSF    F83.3
....................    TRIS_Yp=1; TRIS_Ym=1; 
1980:  BSF    F95.7
1982:  BSF    F95.5
....................    return temp; 
1984:  MOVFF  70,01
1988:  MOVFF  71,02
.................... } 
198C:  GOTO   1ADE (RETURN)
....................  
....................  
....................  
.................... //============================================================================== 
.................... // make touch value to 320X240 Size. 
.................... //============================================================================== 
.................... float x0=0.; 
.................... float y0=63.; 
.................... float x240=3022.; 
.................... float y320=3295.; 
....................  
.................... unsigned int16 convert_X(unsigned int16 X) 
.................... { 
....................    unsigned int16 pix_X; 
....................    if(X<x0) 
*
1578:  MOVFF  73,7B
157C:  MOVFF  72,7A
1580:  RCALL  0FDE
1582:  MOVFF  03,8D
1586:  MOVFF  02,8C
158A:  MOVFF  01,8B
158E:  MOVFF  00,8A
1592:  MOVFF  23,91
1596:  MOVFF  22,90
159A:  MOVFF  21,8F
159E:  MOVFF  20,8E
15A2:  RCALL  1014
15A4:  BNC   15AC
....................       X=0; 
15A6:  CLRF   73
15A8:  CLRF   72
....................    else 
15AA:  BRA    15F4
....................       X=X-x0; 
15AC:  MOVFF  73,7B
15B0:  MOVFF  72,7A
15B4:  RCALL  0FDE
15B6:  BSF    FD8.1
15B8:  MOVFF  03,8D
15BC:  MOVFF  02,8C
15C0:  MOVFF  01,8B
15C4:  MOVFF  00,8A
15C8:  MOVFF  23,91
15CC:  MOVFF  22,90
15D0:  MOVFF  21,8F
15D4:  MOVFF  20,8E
15D8:  RCALL  108A
15DA:  MOVFF  03,7B
15DE:  MOVFF  02,7A
15E2:  MOVFF  01,79
15E6:  MOVFF  00,78
15EA:  RCALL  12F4
15EC:  MOVFF  02,73
15F0:  MOVFF  01,72
....................    pix_X = (TFT_W/(x240-x0))*X; //2793 
15F4:  BSF    FD8.1
15F6:  MOVFF  2B,8D
15FA:  MOVFF  2A,8C
15FE:  MOVFF  29,8B
1602:  MOVFF  28,8A
1606:  MOVFF  23,91
160A:  MOVFF  22,90
160E:  MOVFF  21,8F
1612:  MOVFF  20,8E
1616:  RCALL  108A
1618:  CLRF   x8D
161A:  CLRF   x8C
161C:  MOVLW  70
161E:  MOVWF  x8B
1620:  MOVLW  86
1622:  MOVWF  x8A
1624:  MOVFF  03,91
1628:  MOVFF  02,90
162C:  MOVFF  01,8F
1630:  MOVFF  00,8E
1634:  RCALL  132C
1636:  MOVFF  00,76
163A:  MOVFF  01,77
163E:  MOVFF  02,78
1642:  MOVFF  03,79
1646:  MOVFF  73,7B
164A:  MOVFF  72,7A
164E:  RCALL  0FDE
1650:  MOVFF  79,7D
1654:  MOVFF  78,7C
1658:  MOVFF  77,7B
165C:  MOVFF  76,7A
1660:  MOVFF  03,81
1664:  MOVFF  02,80
1668:  MOVFF  01,7F
166C:  MOVFF  00,7E
1670:  RCALL  1486
1672:  MOVFF  03,7B
1676:  MOVFF  02,7A
167A:  MOVFF  01,79
167E:  MOVFF  00,78
1682:  RCALL  12F4
1684:  MOVFF  02,75
1688:  MOVFF  01,74
....................  
....................    return pix_X; 
168C:  MOVFF  74,01
1690:  MOVFF  75,02
.................... } 
1694:  GOTO   1740 (RETURN)
.................... //============================================================================== 
....................  
.................... unsigned int16 convert_Y(unsigned int16 Y) 
.................... { 
....................    unsigned int16 pix_Y; 
....................    if(Y<y0) 
*
1990:  MOVFF  73,7B
1994:  MOVFF  72,7A
1998:  CALL   0FDE
199C:  MOVFF  03,8D
19A0:  MOVFF  02,8C
19A4:  MOVFF  01,8B
19A8:  MOVFF  00,8A
19AC:  MOVFF  27,91
19B0:  MOVFF  26,90
19B4:  MOVFF  25,8F
19B8:  MOVFF  24,8E
19BC:  CALL   1014
19C0:  BNC   19C8
....................       Y=0; 
19C2:  CLRF   73
19C4:  CLRF   72
....................    else 
19C6:  BRA    1A14
....................       Y=Y-y0; 
19C8:  MOVFF  73,7B
19CC:  MOVFF  72,7A
19D0:  CALL   0FDE
19D4:  BSF    FD8.1
19D6:  MOVFF  03,8D
19DA:  MOVFF  02,8C
19DE:  MOVFF  01,8B
19E2:  MOVFF  00,8A
19E6:  MOVFF  27,91
19EA:  MOVFF  26,90
19EE:  MOVFF  25,8F
19F2:  MOVFF  24,8E
19F6:  CALL   108A
19FA:  MOVFF  03,7B
19FE:  MOVFF  02,7A
1A02:  MOVFF  01,79
1A06:  MOVFF  00,78
1A0A:  RCALL  12F4
1A0C:  MOVFF  02,73
1A10:  MOVFF  01,72
....................    pix_Y = (TFT_H/(y320-y0))*Y; //2954 
1A14:  BSF    FD8.1
1A16:  MOVFF  2F,8D
1A1A:  MOVFF  2E,8C
1A1E:  MOVFF  2D,8B
1A22:  MOVFF  2C,8A
1A26:  MOVFF  27,91
1A2A:  MOVFF  26,90
1A2E:  MOVFF  25,8F
1A32:  MOVFF  24,8E
1A36:  CALL   108A
1A3A:  CLRF   x8D
1A3C:  CLRF   x8C
1A3E:  MOVLW  20
1A40:  MOVWF  x8B
1A42:  MOVLW  87
1A44:  MOVWF  x8A
1A46:  MOVFF  03,91
1A4A:  MOVFF  02,90
1A4E:  MOVFF  01,8F
1A52:  MOVFF  00,8E
1A56:  RCALL  132C
1A58:  MOVFF  00,76
1A5C:  MOVFF  01,77
1A60:  MOVFF  02,78
1A64:  MOVFF  03,79
1A68:  MOVFF  73,7B
1A6C:  MOVFF  72,7A
1A70:  CALL   0FDE
1A74:  MOVFF  79,7D
1A78:  MOVFF  78,7C
1A7C:  MOVFF  77,7B
1A80:  MOVFF  76,7A
1A84:  MOVFF  03,81
1A88:  MOVFF  02,80
1A8C:  MOVFF  01,7F
1A90:  MOVFF  00,7E
1A94:  RCALL  1486
1A96:  MOVFF  03,7B
1A9A:  MOVFF  02,7A
1A9E:  MOVFF  01,79
1AA2:  MOVFF  00,78
1AA6:  RCALL  12F4
1AA8:  MOVFF  02,75
1AAC:  MOVFF  01,74
....................  
....................    return pix_Y; 
1AB0:  MOVFF  74,01
1AB4:  MOVFF  75,02
.................... } 
1AB8:  GOTO   1AF0 (RETURN)
.................... //============================================================================== 
.................... // Saving touch value for SMPLSIZE. and make averrage value. 
.................... // don't using maximum & minimum value. 
.................... //============================================================================== 
.................... signed int16 get_touch_Xval(signed int16* X_val) 
.................... { 
....................    int8 i,j; 
....................    signed int16 temp,sumX; 
....................    for(i=0;i<SMPLSIZE;i++) 
*
170C:  CLRF   68
170E:  MOVF   68,W
1710:  SUBLW  09
1712:  BTFSS  FD8.0
1714:  BRA    1804
....................    { 
....................       X_val[i]=convert_X(Read_X()); 
1716:  BCF    FD8.0
1718:  RLCF   68,W
171A:  CLRF   03
171C:  ADDWF  66,W
171E:  MOVWF  01
1720:  MOVF   67,W
1722:  ADDWFC 03,F
1724:  MOVFF  01,6E
1728:  MOVFF  03,6F
172C:  BRA    0F98
172E:  MOVFF  02,71
1732:  MOVFF  01,70
1736:  MOVFF  02,73
173A:  MOVFF  01,72
173E:  BRA    1578
1740:  MOVFF  6F,FEA
1744:  MOVFF  6E,FE9
1748:  MOVFF  02,FEC
174C:  MOVF   FED,F
174E:  MOVFF  01,FEF
....................       if(i>0) 
1752:  MOVF   68,F
1754:  BZ    1800
....................       { 
....................          if(((X_val[i]-X_val[i-1])>5)  ||  (-5>(X_val[i-1]-X_val[i]))) 
1756:  BCF    FD8.0
1758:  RLCF   68,W
175A:  CLRF   03
175C:  ADDWF  66,W
175E:  MOVWF  FE9
1760:  MOVF   67,W
1762:  ADDWFC 03,W
1764:  MOVWF  FEA
1766:  MOVFF  FEC,6F
176A:  MOVF   FED,F
176C:  MOVFF  FEF,6E
1770:  MOVLW  01
1772:  SUBWF  68,W
1774:  MOVWF  00
1776:  BCF    FD8.0
1778:  RLCF   00,F
177A:  MOVF   00,W
177C:  CLRF   03
177E:  ADDWF  66,W
1780:  MOVWF  FE9
1782:  MOVF   67,W
1784:  ADDWFC 03,W
1786:  MOVWF  FEA
1788:  MOVFF  FEC,03
178C:  MOVF   FED,F
178E:  MOVF   FEF,W
1790:  SUBWF  6E,F
1792:  MOVF   03,W
1794:  SUBWFB 6F,F
1796:  BTFSC  6F.7
1798:  BRA    17A4
179A:  MOVF   6F,F
179C:  BNZ   17FE
179E:  MOVF   6E,W
17A0:  SUBLW  05
17A2:  BNC   17FE
17A4:  MOVLW  01
17A6:  SUBWF  68,W
17A8:  MOVWF  00
17AA:  BCF    FD8.0
17AC:  RLCF   00,F
17AE:  MOVF   00,W
17B0:  CLRF   03
17B2:  ADDWF  66,W
17B4:  MOVWF  FE9
17B6:  MOVF   67,W
17B8:  ADDWFC 03,W
17BA:  MOVWF  FEA
17BC:  MOVFF  FEC,6F
17C0:  MOVF   FED,F
17C2:  MOVFF  FEF,6E
17C6:  BCF    FD8.0
17C8:  RLCF   68,W
17CA:  CLRF   03
17CC:  ADDWF  66,W
17CE:  MOVWF  FE9
17D0:  MOVF   67,W
17D2:  ADDWFC 03,W
17D4:  MOVWF  FEA
17D6:  MOVFF  FEC,03
17DA:  MOVF   FED,F
17DC:  MOVF   FEF,W
17DE:  SUBWF  6E,W
17E0:  MOVWF  00
17E2:  MOVF   03,W
17E4:  SUBWFB 6F,W
17E6:  MOVWF  03
17E8:  MOVFF  00,01
17EC:  BTFSS  FE8.7
17EE:  BRA    1800
17F0:  MOVF   03,W
17F2:  SUBLW  FF
17F4:  BNC   1800
17F6:  BNZ   17FE
17F8:  MOVF   01,W
17FA:  SUBLW  FA
17FC:  BNC   1800
....................             i=-1; 
17FE:  SETF   68
....................       } 
....................    } 
1800:  INCF   68,F
1802:  BRA    170E
....................    for(i=0;i<(SMPLSIZE-1);i++) 
1804:  CLRF   68
1806:  MOVF   68,W
1808:  SUBLW  08
180A:  BTFSS  FD8.0
180C:  BRA    18F6
....................    { 
....................       for(j=i+1;j<SMPLSIZE;j++) 
180E:  MOVLW  01
1810:  ADDWF  68,W
1812:  MOVWF  69
1814:  MOVF   69,W
1816:  SUBLW  09
1818:  BNC   18F2
....................       { 
....................          if(*(X_val+i) > *(X_val+j)) 
181A:  BCF    FD8.0
181C:  RLCF   68,W
181E:  ADDWF  66,W
1820:  MOVWF  01
1822:  MOVLW  00
1824:  ADDWFC 67,W
1826:  MOVWF  03
1828:  MOVFF  01,FE9
182C:  MOVWF  FEA
182E:  MOVFF  FEC,6F
1832:  MOVF   FED,F
1834:  MOVFF  FEF,6E
1838:  BCF    FD8.0
183A:  RLCF   69,W
183C:  ADDWF  66,W
183E:  MOVWF  01
1840:  MOVLW  00
1842:  ADDWFC 67,W
1844:  MOVFF  01,FE9
1848:  MOVWF  FEA
184A:  MOVFF  FEC,03
184E:  MOVF   FED,F
1850:  MOVFF  FEF,01
1854:  BTFSS  03.7
1856:  BRA    185E
1858:  BTFSS  6F.7
185A:  BRA    1870
185C:  BRA    1862
185E:  BTFSC  6F.7
1860:  BRA    18EE
1862:  MOVF   03,W
1864:  SUBWF  6F,W
1866:  BNC   18EE
1868:  BNZ   1870
186A:  MOVF   6E,W
186C:  SUBWF  01,W
186E:  BC    18EE
....................          { 
....................             temp = *(X_val+i); 
1870:  BCF    FD8.0
1872:  RLCF   68,W
1874:  ADDWF  66,W
1876:  MOVWF  01
1878:  MOVLW  00
187A:  ADDWFC 67,W
187C:  MOVFF  01,FE9
1880:  MOVWF  FEA
1882:  MOVFF  FEC,03
1886:  MOVF   FED,F
1888:  MOVFF  FEF,6A
188C:  MOVFF  03,6B
....................             *(X_val+i) = *(X_val+j); 
1890:  BCF    FD8.0
1892:  RLCF   68,W
1894:  ADDWF  66,W
1896:  MOVWF  01
1898:  MOVLW  00
189A:  ADDWFC 67,W
189C:  MOVWF  03
189E:  MOVFF  01,6E
18A2:  MOVWF  6F
18A4:  BCF    FD8.0
18A6:  RLCF   69,W
18A8:  ADDWF  66,W
18AA:  MOVWF  01
18AC:  MOVLW  00
18AE:  ADDWFC 67,W
18B0:  MOVFF  01,FE9
18B4:  MOVWF  FEA
18B6:  MOVFF  FEC,03
18BA:  MOVF   FED,F
18BC:  MOVFF  FEF,70
18C0:  MOVFF  6F,FEA
18C4:  MOVFF  6E,FE9
18C8:  MOVFF  03,FEC
18CC:  MOVF   FED,F
18CE:  MOVFF  70,FEF
....................             *(X_val+j) = temp; 
18D2:  BCF    FD8.0
18D4:  RLCF   69,W
18D6:  ADDWF  66,W
18D8:  MOVWF  01
18DA:  MOVLW  00
18DC:  ADDWFC 67,W
18DE:  MOVFF  01,FE9
18E2:  MOVWF  FEA
18E4:  MOVFF  6B,FEC
18E8:  MOVF   FED,F
18EA:  MOVFF  6A,FEF
....................          } 
....................       } 
18EE:  INCF   69,F
18F0:  BRA    1814
....................    } 
18F2:  INCF   68,F
18F4:  BRA    1806
....................    sumX=0; 
18F6:  CLRF   6D
18F8:  CLRF   6C
....................    for(i=1;i<(SMPLSIZE-1);i++) 
18FA:  MOVLW  01
18FC:  MOVWF  68
18FE:  MOVF   68,W
1900:  SUBLW  08
1902:  BNC   1926
....................    { 
....................       sumX+=X_val[i]; 
1904:  BCF    FD8.0
1906:  RLCF   68,W
1908:  CLRF   03
190A:  ADDWF  66,W
190C:  MOVWF  FE9
190E:  MOVF   67,W
1910:  ADDWFC 03,W
1912:  MOVWF  FEA
1914:  MOVFF  FEC,03
1918:  MOVF   FED,F
191A:  MOVF   FEF,W
191C:  ADDWF  6C,F
191E:  MOVF   03,W
1920:  ADDWFC 6D,F
....................    } 
1922:  INCF   68,F
1924:  BRA    18FE
....................    sumX=sumX/(SMPLSIZE-2); 
1926:  MOVFF  6D,6F
192A:  MOVFF  6C,6E
192E:  CLRF   71
1930:  MOVLW  08
1932:  MOVWF  70
1934:  RCALL  1698
1936:  MOVFF  02,6D
193A:  MOVFF  01,6C
....................     
....................    return sumX; 
193E:  MOVFF  6C,01
1942:  MOVFF  6D,02
.................... } 
1946:  GOTO   22B4 (RETURN)
.................... //============================================================================== 
....................  
.................... signed int16 get_touch_Yval(signed int16* Y_val) 
.................... { 
....................    int8 i,j; 
....................    signed int16 temp,sumY; 
....................    for(i=0;i<SMPLSIZE;i++) 
*
1ABC:  CLRF   68
1ABE:  MOVF   68,W
1AC0:  SUBLW  09
1AC2:  BTFSS  FD8.0
1AC4:  BRA    1BB4
....................    { 
....................       Y_val[i]=convert_Y(Read_Y()); 
1AC6:  BCF    FD8.0
1AC8:  RLCF   68,W
1ACA:  CLRF   03
1ACC:  ADDWF  66,W
1ACE:  MOVWF  01
1AD0:  MOVF   67,W
1AD2:  ADDWFC 03,F
1AD4:  MOVFF  01,6E
1AD8:  MOVFF  03,6F
1ADC:  BRA    194A
1ADE:  MOVFF  02,71
1AE2:  MOVFF  01,70
1AE6:  MOVFF  02,73
1AEA:  MOVFF  01,72
1AEE:  BRA    1990
1AF0:  MOVFF  6F,FEA
1AF4:  MOVFF  6E,FE9
1AF8:  MOVFF  02,FEC
1AFC:  MOVF   FED,F
1AFE:  MOVFF  01,FEF
....................       if(i>0) 
1B02:  MOVF   68,F
1B04:  BZ    1BB0
....................       { 
....................          if(  (  (Y_val[i]-Y_val[i-1]) > 5)  ||  ( -5 > (Y_val[i-1]-Y_val[i])  )  ) 
1B06:  BCF    FD8.0
1B08:  RLCF   68,W
1B0A:  CLRF   03
1B0C:  ADDWF  66,W
1B0E:  MOVWF  FE9
1B10:  MOVF   67,W
1B12:  ADDWFC 03,W
1B14:  MOVWF  FEA
1B16:  MOVFF  FEC,6F
1B1A:  MOVF   FED,F
1B1C:  MOVFF  FEF,6E
1B20:  MOVLW  01
1B22:  SUBWF  68,W
1B24:  MOVWF  00
1B26:  BCF    FD8.0
1B28:  RLCF   00,F
1B2A:  MOVF   00,W
1B2C:  CLRF   03
1B2E:  ADDWF  66,W
1B30:  MOVWF  FE9
1B32:  MOVF   67,W
1B34:  ADDWFC 03,W
1B36:  MOVWF  FEA
1B38:  MOVFF  FEC,03
1B3C:  MOVF   FED,F
1B3E:  MOVF   FEF,W
1B40:  SUBWF  6E,F
1B42:  MOVF   03,W
1B44:  SUBWFB 6F,F
1B46:  BTFSC  6F.7
1B48:  BRA    1B54
1B4A:  MOVF   6F,F
1B4C:  BNZ   1BAE
1B4E:  MOVF   6E,W
1B50:  SUBLW  05
1B52:  BNC   1BAE
1B54:  MOVLW  01
1B56:  SUBWF  68,W
1B58:  MOVWF  00
1B5A:  BCF    FD8.0
1B5C:  RLCF   00,F
1B5E:  MOVF   00,W
1B60:  CLRF   03
1B62:  ADDWF  66,W
1B64:  MOVWF  FE9
1B66:  MOVF   67,W
1B68:  ADDWFC 03,W
1B6A:  MOVWF  FEA
1B6C:  MOVFF  FEC,6F
1B70:  MOVF   FED,F
1B72:  MOVFF  FEF,6E
1B76:  BCF    FD8.0
1B78:  RLCF   68,W
1B7A:  CLRF   03
1B7C:  ADDWF  66,W
1B7E:  MOVWF  FE9
1B80:  MOVF   67,W
1B82:  ADDWFC 03,W
1B84:  MOVWF  FEA
1B86:  MOVFF  FEC,03
1B8A:  MOVF   FED,F
1B8C:  MOVF   FEF,W
1B8E:  SUBWF  6E,W
1B90:  MOVWF  00
1B92:  MOVF   03,W
1B94:  SUBWFB 6F,W
1B96:  MOVWF  03
1B98:  MOVFF  00,01
1B9C:  BTFSS  FE8.7
1B9E:  BRA    1BB0
1BA0:  MOVF   03,W
1BA2:  SUBLW  FF
1BA4:  BNC   1BB0
1BA6:  BNZ   1BAE
1BA8:  MOVF   01,W
1BAA:  SUBLW  FA
1BAC:  BNC   1BB0
....................             i=-1; 
1BAE:  SETF   68
....................       } 
....................    } 
1BB0:  INCF   68,F
1BB2:  BRA    1ABE
....................    for(i=0;i<(SMPLSIZE-1);i++) 
1BB4:  CLRF   68
1BB6:  MOVF   68,W
1BB8:  SUBLW  08
1BBA:  BTFSS  FD8.0
1BBC:  BRA    1CA6
....................    { 
....................       for(j=i+1;j<SMPLSIZE;j++) 
1BBE:  MOVLW  01
1BC0:  ADDWF  68,W
1BC2:  MOVWF  69
1BC4:  MOVF   69,W
1BC6:  SUBLW  09
1BC8:  BNC   1CA2
....................       { 
....................          if(*(Y_val+i) > *(Y_val+j)) 
1BCA:  BCF    FD8.0
1BCC:  RLCF   68,W
1BCE:  ADDWF  66,W
1BD0:  MOVWF  01
1BD2:  MOVLW  00
1BD4:  ADDWFC 67,W
1BD6:  MOVWF  03
1BD8:  MOVFF  01,FE9
1BDC:  MOVWF  FEA
1BDE:  MOVFF  FEC,6F
1BE2:  MOVF   FED,F
1BE4:  MOVFF  FEF,6E
1BE8:  BCF    FD8.0
1BEA:  RLCF   69,W
1BEC:  ADDWF  66,W
1BEE:  MOVWF  01
1BF0:  MOVLW  00
1BF2:  ADDWFC 67,W
1BF4:  MOVFF  01,FE9
1BF8:  MOVWF  FEA
1BFA:  MOVFF  FEC,03
1BFE:  MOVF   FED,F
1C00:  MOVFF  FEF,01
1C04:  BTFSS  03.7
1C06:  BRA    1C0E
1C08:  BTFSS  6F.7
1C0A:  BRA    1C20
1C0C:  BRA    1C12
1C0E:  BTFSC  6F.7
1C10:  BRA    1C9E
1C12:  MOVF   03,W
1C14:  SUBWF  6F,W
1C16:  BNC   1C9E
1C18:  BNZ   1C20
1C1A:  MOVF   6E,W
1C1C:  SUBWF  01,W
1C1E:  BC    1C9E
....................          { 
....................             temp = *(Y_val+i); 
1C20:  BCF    FD8.0
1C22:  RLCF   68,W
1C24:  ADDWF  66,W
1C26:  MOVWF  01
1C28:  MOVLW  00
1C2A:  ADDWFC 67,W
1C2C:  MOVFF  01,FE9
1C30:  MOVWF  FEA
1C32:  MOVFF  FEC,03
1C36:  MOVF   FED,F
1C38:  MOVFF  FEF,6A
1C3C:  MOVFF  03,6B
....................             *(Y_val+i) = *(Y_val+j); 
1C40:  BCF    FD8.0
1C42:  RLCF   68,W
1C44:  ADDWF  66,W
1C46:  MOVWF  01
1C48:  MOVLW  00
1C4A:  ADDWFC 67,W
1C4C:  MOVWF  03
1C4E:  MOVFF  01,6E
1C52:  MOVWF  6F
1C54:  BCF    FD8.0
1C56:  RLCF   69,W
1C58:  ADDWF  66,W
1C5A:  MOVWF  01
1C5C:  MOVLW  00
1C5E:  ADDWFC 67,W
1C60:  MOVFF  01,FE9
1C64:  MOVWF  FEA
1C66:  MOVFF  FEC,03
1C6A:  MOVF   FED,F
1C6C:  MOVFF  FEF,70
1C70:  MOVFF  6F,FEA
1C74:  MOVFF  6E,FE9
1C78:  MOVFF  03,FEC
1C7C:  MOVF   FED,F
1C7E:  MOVFF  70,FEF
....................             *(Y_val+j) = temp; 
1C82:  BCF    FD8.0
1C84:  RLCF   69,W
1C86:  ADDWF  66,W
1C88:  MOVWF  01
1C8A:  MOVLW  00
1C8C:  ADDWFC 67,W
1C8E:  MOVFF  01,FE9
1C92:  MOVWF  FEA
1C94:  MOVFF  6B,FEC
1C98:  MOVF   FED,F
1C9A:  MOVFF  6A,FEF
....................          } 
....................       } 
1C9E:  INCF   69,F
1CA0:  BRA    1BC4
....................    } 
1CA2:  INCF   68,F
1CA4:  BRA    1BB6
....................    sumY=0; 
1CA6:  CLRF   6D
1CA8:  CLRF   6C
....................    for(i=1;i<(SMPLSIZE-1);i++) 
1CAA:  MOVLW  01
1CAC:  MOVWF  68
1CAE:  MOVF   68,W
1CB0:  SUBLW  08
1CB2:  BNC   1CD6
....................    { 
....................       sumY+=Y_val[i]; 
1CB4:  BCF    FD8.0
1CB6:  RLCF   68,W
1CB8:  CLRF   03
1CBA:  ADDWF  66,W
1CBC:  MOVWF  FE9
1CBE:  MOVF   67,W
1CC0:  ADDWFC 03,W
1CC2:  MOVWF  FEA
1CC4:  MOVFF  FEC,03
1CC8:  MOVF   FED,F
1CCA:  MOVF   FEF,W
1CCC:  ADDWF  6C,F
1CCE:  MOVF   03,W
1CD0:  ADDWFC 6D,F
....................    } 
1CD2:  INCF   68,F
1CD4:  BRA    1CAE
....................    sumY=sumY/(SMPLSIZE-2); 
1CD6:  MOVFF  6D,6F
1CDA:  MOVFF  6C,6E
1CDE:  CLRF   71
1CE0:  MOVLW  08
1CE2:  MOVWF  70
1CE4:  RCALL  1698
1CE6:  MOVFF  02,6D
1CEA:  MOVFF  01,6C
....................     
....................    return sumY; 
1CEE:  MOVFF  6C,01
1CF2:  MOVFF  6D,02
.................... } 
1CF6:  GOTO   22C6 (RETURN)
....................  
.................... #use delay(clock=20000000) 
.................... #use RS232(baud=9600, parity=N, xmit=PIN_C6, rcv=PIN_C7) 
....................  
.................... #byte PORTB=0xF81 
.................... #byte TRISB=0xF93 
....................  
.................... #byte INTCON=0xFF2 
.................... #byte INTCON2=0xFF1 
.................... #byte PIE1=0xF9D 
.................... #byte PIR1 = 0xf9e 
.................... #bit GIE=INTCON.7 
....................  
.................... #byte RCREG=0xFAE 
.................... #byte TXSTA=0xFAC 
.................... #byte TXREG=0xFAD 
.................... #byte RCSTA=0xFAB 
.................... #byte SPBRG=0xFAF 
.................... #bit TRIS_RX=TRISC.7 
.................... #bit TRIS_TX=TRISC.6 
....................  
.................... unsigned int16 X_val[SMPLSIZE]; 
.................... unsigned int16 Y_val[SMPLSIZE]; 
.................... unsigned int16 color; 
....................  
.................... char rcv_data=0; 
.................... char arr[6]; 
.................... char cnt=0; 
....................  
.................... #int_ext 
.................... void ext_isr(){ 
....................    SSPSTAT = 0b00000000;      // 0 = Data transmitted on rising edge of SCK 
*
03F4:  CLRF   FC7
....................    SSPCON1 = 0b00110001;      // 1 = Enables, 1 = IDLE state for clock is a high level,FOSC/16 
03F6:  MOVLW  31
03F8:  MOVWF  FC6
....................    SSPIF = 0;                 //spi crashed mcp3202 & TFTLCD. so must be reset spi 
03FA:  BCF    F9E.3
....................    TFT_Box(0, 0, 240, 279, BLACK); 
03FC:  CLRF   xAE
03FE:  CLRF   xAD
0400:  CLRF   xB0
0402:  CLRF   xAF
0404:  CLRF   xB2
0406:  MOVLW  F0
0408:  MOVWF  xB1
040A:  MOVLW  01
040C:  MOVWF  xB4
040E:  MOVLW  17
0410:  MOVWF  xB3
0412:  CLRF   xB6
0414:  CLRF   xB5
0416:  RCALL  0378
.................... } 
....................  
0418:  BCF    FF2.1
041A:  GOTO   026C
.................... #int_rda 
.................... void rda_isr(){ 
....................    rcv_data=RCREG; 
041E:  MOVFF  FAE,5A
....................    switch(cnt) 
....................    { 
0422:  MOVF   61,W
0424:  BZ    043C
0426:  XORLW  01
0428:  BZ    045C
042A:  XORLW  03
042C:  BZ    047C
042E:  XORLW  01
0430:  BZ    0492
0432:  XORLW  07
0434:  BZ    04A8
0436:  XORLW  01
0438:  BZ    04C8
043A:  BRA    04F2
....................       case 0 :  
....................          if(RCREG=='s') 
043C:  MOVF   FAE,W
043E:  SUBLW  73
0440:  BNZ   0458
....................             arr[cnt++] = RCREG; 
0442:  MOVF   61,W
0444:  INCF   61,F
0446:  CLRF   03
0448:  ADDLW  5B
044A:  MOVWF  FE9
044C:  MOVLW  00
044E:  ADDWFC 03,W
0450:  MOVWF  FEA
0452:  MOVFF  FAE,FEF
....................          else cnt=0; 
0456:  BRA    045A
0458:  CLRF   61
....................          break; 
045A:  BRA    04F6
....................       case 1 :  
....................          if(RCREG=='s') 
045C:  MOVF   FAE,W
045E:  SUBLW  73
0460:  BNZ   0478
....................             arr[cnt++] = RCREG; 
0462:  MOVF   61,W
0464:  INCF   61,F
0466:  CLRF   03
0468:  ADDLW  5B
046A:  MOVWF  FE9
046C:  MOVLW  00
046E:  ADDWFC 03,W
0470:  MOVWF  FEA
0472:  MOVFF  FAE,FEF
....................          else cnt=0; 
0476:  BRA    047A
0478:  CLRF   61
....................          break; 
047A:  BRA    04F6
....................       case 2 : 
....................          arr[cnt++] = RCREG; 
047C:  MOVF   61,W
047E:  INCF   61,F
0480:  CLRF   03
0482:  ADDLW  5B
0484:  MOVWF  FE9
0486:  MOVLW  00
0488:  ADDWFC 03,W
048A:  MOVWF  FEA
048C:  MOVFF  FAE,FEF
....................          break; 
0490:  BRA    04F6
....................       case 3 : 
....................          arr[cnt++] = RCREG; 
0492:  MOVF   61,W
0494:  INCF   61,F
0496:  CLRF   03
0498:  ADDLW  5B
049A:  MOVWF  FE9
049C:  MOVLW  00
049E:  ADDWFC 03,W
04A0:  MOVWF  FEA
04A2:  MOVFF  FAE,FEF
....................          break; 
04A6:  BRA    04F6
....................       case 4 :  
....................          if(RCREG=='p') 
04A8:  MOVF   FAE,W
04AA:  SUBLW  70
04AC:  BNZ   04C4
....................             arr[cnt++] = RCREG; 
04AE:  MOVF   61,W
04B0:  INCF   61,F
04B2:  CLRF   03
04B4:  ADDLW  5B
04B6:  MOVWF  FE9
04B8:  MOVLW  00
04BA:  ADDWFC 03,W
04BC:  MOVWF  FEA
04BE:  MOVFF  FAE,FEF
....................          else cnt=0; 
04C2:  BRA    04C6
04C4:  CLRF   61
....................          break; 
04C6:  BRA    04F6
....................       case 5 : 
....................          if(RCREG=='p'){ 
04C8:  MOVF   FAE,W
04CA:  SUBLW  70
04CC:  BNZ   04EE
....................             arr[cnt] = RCREG; 
04CE:  CLRF   03
04D0:  MOVF   61,W
04D2:  ADDLW  5B
04D4:  MOVWF  FE9
04D6:  MOVLW  00
04D8:  ADDWFC 03,W
04DA:  MOVWF  FEA
04DC:  MOVFF  FAE,FEF
....................             color = ((long)arr[2]*0x0100); 
04E0:  MOVFF  5D,59
04E4:  CLRF   58
....................             color += arr[3]; 
04E6:  MOVF   5E,W
04E8:  ADDWF  58,F
04EA:  MOVLW  00
04EC:  ADDWFC 59,F
....................          } 
....................          cnt=0; 
04EE:  CLRF   61
....................          break; 
04F0:  BRA    04F6
....................       default:  
....................          cnt=0; 
04F2:  CLRF   61
....................          break; 
04F4:  BRA    04F6
....................    } 
.................... } 
....................  
04F6:  BCF    F9E.5
04F8:  GOTO   026C
.................... void uart_init(void){ 
....................    TRIS_RX=1;  TRIS_TX=0; 
*
0BDC:  BSF    F94.7
0BDE:  BCF    F94.6
....................    TXSTA=0xa4;//10100100 
0BE0:  MOVLW  A4
0BE2:  MOVWF  FAC
....................    RCSTA=0x90;//10010000 
0BE4:  MOVLW  90
0BE6:  MOVWF  FAB
....................    SPBRG=0x81;//10000001 
0BE8:  MOVLW  81
0BEA:  MOVWF  FAF
....................    INTCON=0xc0;//11000000 
0BEC:  MOVLW  C0
0BEE:  MOVWF  FF2
....................    PIE1=PIE1|0x20;//00100000 
0BF0:  BSF    F9D.5
.................... } 
0BF2:  GOTO   229E (RETURN)
.................... void init_spi(void) 
.................... { 
....................    TRIS_SDO = 0; TRIS_SDI = 1; TRIS_SCK = 0; 
*
04FC:  BCF    F94.5
04FE:  BSF    F94.4
0500:  BCF    F94.3
....................    SSPCON1 &=0xDF; 
0502:  BCF    FC6.5
....................    SSPSTAT &= 0x3F;                // power on state  
0504:  MOVLW  3F
0506:  ANDWF  FC7,F
....................    SSPCON1 = 0x00;                 // power on state 
0508:  CLRF   FC6
....................  
....................    SSPSTAT = 0b00000000;           // 0 = Data transmitted on rising edge of SCK 
050A:  CLRF   FC7
....................    SSPCON1 = 0b00110001;           // 1 = Enables, 1 = IDLE state for clock is a high level,FOSC/16 
050C:  MOVLW  31
050E:  MOVWF  FC6
....................    SSPIF = 0; 
0510:  BCF    F9E.3
.................... } 
0512:  RETURN 0
....................  
.................... void init_ext0(void) 
.................... { 
....................    TRISB  = 0x01; 
*
0BF6:  MOVLW  01
0BF8:  MOVWF  F93
....................    INTCON=INTCON|0x10;     //1 = Enables the INT0 external interrupt 
0BFA:  BSF    FF2.4
....................    INTCON2=INTCON2&0xBF;   //0 = Interrupt on falling edge 
0BFC:  BCF    FF1.6
....................    GIE=1; 
0BFE:  BSF    FF2.7
.................... } 
0C00:  GOTO   22A2 (RETURN)
.................... void paint_layout(void) 
.................... { 
....................    TFT_FillScreen(BLACK); 
*
0E6E:  CLRF   67
0E70:  CLRF   66
0E72:  CALL   0574
....................    TFT_Line(0, 279, 240, 279, GRAY2);  
0E76:  CLRF   x81
0E78:  CLRF   x80
0E7A:  MOVLW  01
0E7C:  MOVWF  x83
0E7E:  MOVLW  17
0E80:  MOVWF  x82
0E82:  CLRF   x85
0E84:  MOVLW  F0
0E86:  MOVWF  x84
0E88:  MOVLW  01
0E8A:  MOVWF  x87
0E8C:  MOVLW  17
0E8E:  MOVWF  x86
0E90:  MOVLW  A5
0E92:  MOVWF  x89
0E94:  MOVLW  14
0E96:  MOVWF  x88
0E98:  RCALL  0D5C
0E9A:  CLRF   19
0E9C:  BTFSC  FF2.7
0E9E:  BSF    19.7
0EA0:  BCF    FF2.7
....................    TFT_Box(40, 280, 80, 319, WHITE);  
0EA2:  CLRF   xAE
0EA4:  MOVLW  28
0EA6:  MOVWF  xAD
0EA8:  MOVLW  01
0EAA:  MOVWF  xB0
0EAC:  MOVLW  18
0EAE:  MOVWF  xAF
0EB0:  CLRF   xB2
0EB2:  MOVLW  50
0EB4:  MOVWF  xB1
0EB6:  MOVLW  01
0EB8:  MOVWF  xB4
0EBA:  MOVLW  3F
0EBC:  MOVWF  xB3
0EBE:  SETF   xB6
0EC0:  SETF   xB5
0EC2:  CALL   0378
0EC6:  BTFSC  19.7
0EC8:  BSF    FF2.7
0ECA:  CLRF   19
0ECC:  BTFSC  FF2.7
0ECE:  BSF    19.7
0ED0:  BCF    FF2.7
....................    TFT_Box(80, 280, 120, 319, BRIGHTRED);  
0ED2:  CLRF   xAE
0ED4:  MOVLW  50
0ED6:  MOVWF  xAD
0ED8:  MOVLW  01
0EDA:  MOVWF  xB0
0EDC:  MOVLW  18
0EDE:  MOVWF  xAF
0EE0:  CLRF   xB2
0EE2:  MOVLW  78
0EE4:  MOVWF  xB1
0EE6:  MOVLW  01
0EE8:  MOVWF  xB4
0EEA:  MOVLW  3F
0EEC:  MOVWF  xB3
0EEE:  MOVLW  F8
0EF0:  MOVWF  xB6
0EF2:  CLRF   xB5
0EF4:  CALL   0378
0EF8:  BTFSC  19.7
0EFA:  BSF    FF2.7
0EFC:  CLRF   19
0EFE:  BTFSC  FF2.7
0F00:  BSF    19.7
0F02:  BCF    FF2.7
....................    TFT_Box(120, 280, 160, 319, BRIGHTGREEN);  
0F04:  CLRF   xAE
0F06:  MOVLW  78
0F08:  MOVWF  xAD
0F0A:  MOVLW  01
0F0C:  MOVWF  xB0
0F0E:  MOVLW  18
0F10:  MOVWF  xAF
0F12:  CLRF   xB2
0F14:  MOVLW  A0
0F16:  MOVWF  xB1
0F18:  MOVLW  01
0F1A:  MOVWF  xB4
0F1C:  MOVLW  3F
0F1E:  MOVWF  xB3
0F20:  MOVLW  07
0F22:  MOVWF  xB6
0F24:  MOVLW  E0
0F26:  MOVWF  xB5
0F28:  CALL   0378
0F2C:  BTFSC  19.7
0F2E:  BSF    FF2.7
0F30:  CLRF   19
0F32:  BTFSC  FF2.7
0F34:  BSF    19.7
0F36:  BCF    FF2.7
....................    TFT_Box(160, 280, 200, 319, BRIGHTBLUE);  
0F38:  CLRF   xAE
0F3A:  MOVLW  A0
0F3C:  MOVWF  xAD
0F3E:  MOVLW  01
0F40:  MOVWF  xB0
0F42:  MOVLW  18
0F44:  MOVWF  xAF
0F46:  CLRF   xB2
0F48:  MOVLW  C8
0F4A:  MOVWF  xB1
0F4C:  MOVLW  01
0F4E:  MOVWF  xB4
0F50:  MOVLW  3F
0F52:  MOVWF  xB3
0F54:  CLRF   xB6
0F56:  MOVLW  1F
0F58:  MOVWF  xB5
0F5A:  CALL   0378
0F5E:  BTFSC  19.7
0F60:  BSF    FF2.7
0F62:  CLRF   19
0F64:  BTFSC  FF2.7
0F66:  BSF    19.7
0F68:  BCF    FF2.7
....................    TFT_Box(200, 280, 240, 319, BRIGHTYELLOW);  
0F6A:  CLRF   xAE
0F6C:  MOVLW  C8
0F6E:  MOVWF  xAD
0F70:  MOVLW  01
0F72:  MOVWF  xB0
0F74:  MOVLW  18
0F76:  MOVWF  xAF
0F78:  CLRF   xB2
0F7A:  MOVLW  F0
0F7C:  MOVWF  xB1
0F7E:  MOVLW  01
0F80:  MOVWF  xB4
0F82:  MOVLW  3F
0F84:  MOVWF  xB3
0F86:  SETF   xB6
0F88:  MOVLW  E0
0F8A:  MOVWF  xB5
0F8C:  CALL   0378
0F90:  BTFSC  19.7
0F92:  BSF    FF2.7
.................... } 
0F94:  GOTO   22A6 (RETURN)
.................... void main(){ 
*
222C:  CLRF   FF8
222E:  BCF    FD0.7
2230:  BSF    07.7
2232:  CLRF   FEA
2234:  CLRF   FE9
2236:  CLRF   23
2238:  CLRF   22
223A:  CLRF   21
223C:  CLRF   20
223E:  CLRF   27
2240:  CLRF   26
2242:  MOVLW  7C
2244:  MOVWF  25
2246:  MOVLW  84
2248:  MOVWF  24
224A:  CLRF   2B
224C:  MOVLW  E0
224E:  MOVWF  2A
2250:  MOVLW  3C
2252:  MOVWF  29
2254:  MOVLW  8A
2256:  MOVWF  28
2258:  CLRF   2F
225A:  MOVLW  F0
225C:  MOVWF  2E
225E:  MOVLW  4D
2260:  MOVWF  2D
2262:  MOVLW  8A
2264:  MOVWF  2C
2266:  MOVLW  81
2268:  MOVWF  FAF
226A:  MOVLW  A6
226C:  MOVWF  FAC
226E:  MOVLW  90
2270:  MOVWF  FAB
2272:  CLRF   5A
2274:  CLRF   61
2276:  BSF    FC1.0
2278:  BSF    FC1.1
227A:  BSF    FC1.2
227C:  BCF    FC1.3
227E:  CLRF   1A
2280:  CLRF   1B
....................    unsigned int16 x, y; 
....................     
....................    PORTC  = 0;   PORTD  = 0;   PORTB  = 0; 
2282:  CLRF   F82
2284:  CLRF   F83
2286:  CLRF   F81
....................    TRISC  = 0;   TRISD  = 0;   TRISB  = 0; 
2288:  CLRF   F94
228A:  CLRF   F95
228C:  CLRF   F93
....................     
....................    init_spi(); 
228E:  CALL   04FC
....................    touch_init(); 
2292:  GOTO   0514
....................    TFT_Init(); 
2296:  GOTO   05F6
....................    uart_init(); 
229A:  GOTO   0BDC
....................    init_ext0(); 
229E:  GOTO   0BF6
....................  
....................    paint_layout(); 
22A2:  GOTO   0E6E
....................     
....................    color=WHITE; 
22A6:  SETF   59
22A8:  SETF   58
....................    while(1){ 
....................       x=get_touch_Xval(X_val); 
22AA:  CLRF   67
22AC:  MOVLW  30
22AE:  MOVWF  66
22B0:  GOTO   170C
22B4:  MOVFF  02,63
22B8:  MOVFF  01,62
....................       y=get_touch_Yval(Y_val); 
22BC:  CLRF   67
22BE:  MOVLW  44
22C0:  MOVWF  66
22C2:  GOTO   1ABC
22C6:  MOVFF  02,65
22CA:  MOVFF  01,64
....................  
....................       if((x<3)||(y<3)||((y>275)&&(y<280))) 
22CE:  MOVF   63,F
22D0:  BNZ   22D8
22D2:  MOVF   62,W
22D4:  SUBLW  02
22D6:  BC    2300
22D8:  MOVF   65,F
22DA:  BNZ   22E2
22DC:  MOVF   64,W
22DE:  SUBLW  02
22E0:  BC    2300
22E2:  MOVF   65,W
22E4:  SUBLW  00
22E6:  BC    2302
22E8:  XORLW  FF
22EA:  BNZ   22F2
22EC:  MOVF   64,W
22EE:  SUBLW  13
22F0:  BC    2302
22F2:  MOVF   65,W
22F4:  SUBLW  01
22F6:  BNC   2302
22F8:  BNZ   2300
22FA:  MOVF   64,W
22FC:  SUBLW  17
22FE:  BNC   2302
....................          color = color; 
....................       else if((x<41)&&(y>279)) 
2300:  BRA    23F6
2302:  MOVF   63,F
2304:  BNZ   2322
2306:  MOVF   62,W
2308:  SUBLW  28
230A:  BNC   2322
230C:  MOVF   65,W
230E:  SUBLW  00
2310:  BC    2322
2312:  XORLW  FF
2314:  BNZ   231C
2316:  MOVF   64,W
2318:  SUBLW  17
231A:  BC    2322
....................          color = BLACK; 
231C:  CLRF   59
231E:  CLRF   58
....................       else if((x<81)&&(y>279)) 
2320:  BRA    23F6
2322:  MOVF   63,F
2324:  BNZ   2342
2326:  MOVF   62,W
2328:  SUBLW  50
232A:  BNC   2342
232C:  MOVF   65,W
232E:  SUBLW  00
2330:  BC    2342
2332:  XORLW  FF
2334:  BNZ   233C
2336:  MOVF   64,W
2338:  SUBLW  17
233A:  BC    2342
....................          color = WHITE; 
233C:  SETF   59
233E:  SETF   58
....................       else if((x<121)&&(y>279)) 
2340:  BRA    23F6
2342:  MOVF   63,F
2344:  BNZ   2364
2346:  MOVF   62,W
2348:  SUBLW  78
234A:  BNC   2364
234C:  MOVF   65,W
234E:  SUBLW  00
2350:  BC    2364
2352:  XORLW  FF
2354:  BNZ   235C
2356:  MOVF   64,W
2358:  SUBLW  17
235A:  BC    2364
....................          color = BRIGHTRED; 
235C:  MOVLW  F8
235E:  MOVWF  59
2360:  CLRF   58
....................       else if((x<161)&&(y>279)) 
2362:  BRA    23F6
2364:  MOVF   63,F
2366:  BNZ   2388
2368:  MOVF   62,W
236A:  SUBLW  A0
236C:  BNC   2388
236E:  MOVF   65,W
2370:  SUBLW  00
2372:  BC    2388
2374:  XORLW  FF
2376:  BNZ   237E
2378:  MOVF   64,W
237A:  SUBLW  17
237C:  BC    2388
....................          color = BRIGHTGREEN; 
237E:  MOVLW  07
2380:  MOVWF  59
2382:  MOVLW  E0
2384:  MOVWF  58
....................       else if((x<201)&&(y>279)) 
2386:  BRA    23F6
2388:  MOVF   63,F
238A:  BNZ   23AA
238C:  MOVF   62,W
238E:  SUBLW  C8
2390:  BNC   23AA
2392:  MOVF   65,W
2394:  SUBLW  00
2396:  BC    23AA
2398:  XORLW  FF
239A:  BNZ   23A2
239C:  MOVF   64,W
239E:  SUBLW  17
23A0:  BC    23AA
....................          color = BRIGHTBLUE; 
23A2:  CLRF   59
23A4:  MOVLW  1F
23A6:  MOVWF  58
....................       else if((x<240)&&(y>279)) 
23A8:  BRA    23F6
23AA:  MOVF   63,F
23AC:  BNZ   23CC
23AE:  MOVF   62,W
23B0:  SUBLW  EF
23B2:  BNC   23CC
23B4:  MOVF   65,W
23B6:  SUBLW  00
23B8:  BC    23CC
23BA:  XORLW  FF
23BC:  BNZ   23C4
23BE:  MOVF   64,W
23C0:  SUBLW  17
23C2:  BC    23CC
....................          color = BRIGHTYELLOW; 
23C4:  SETF   59
23C6:  MOVLW  E0
23C8:  MOVWF  58
....................       else  { 
23CA:  BRA    23F6
....................          init_spi(); 
23CC:  CALL   04FC
....................          TFT_Circle(x, y, 3,1, color); 
23D0:  MOVFF  63,67
23D4:  MOVFF  62,66
23D8:  MOVFF  65,69
23DC:  MOVFF  64,68
23E0:  CLRF   6B
23E2:  MOVLW  03
23E4:  MOVWF  6A
23E6:  CLRF   6D
23E8:  MOVLW  01
23EA:  MOVWF  6C
23EC:  MOVFF  59,6F
23F0:  MOVFF  58,6E
23F4:  BRA    1E2C
....................       } 
....................    } 
23F6:  BRA    22AA
.................... } 
23F8:  SLEEP 

Configuration Fuses:
   Word  1: 2200   HS NOOSCSEN
   Word  2: 0E0E   PUT BROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
